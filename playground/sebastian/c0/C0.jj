options{
 /* KEEP_LINE_COLUMN       = true; // Accessed by: System.out.prvoidln(t.beginLine +" " + t.beginColumn +" " + t.endLine +" " + t.endColumn); */
	DEBUG_PARSER  = true;
	DEBUG_TOKEN_MANAGER = true;
 }

PARSER_BEGIN(C0)
public class C0 {
   public static void main(String[] args) throws Exception {
        new C0(System.in).Tp();
        System.out.println("finished");
    }
}
PARSER_END(C0)

TOKEN: 
{ 
	<NUM: <DECNUM> | <HEXNUM>>
|	<DECNUM: "0" | ["1"-"9"](["0"-"9"])*>
|	<HEXNUM: "0" ["x","X"](["0"-"9","a"-"z","A"-"Z"])+>
|	<TRUE: "true">
|	<FALSE: "false">
|	<NULL: "null">
|	<INT: "int">
|	<BOOL: "bool">
|	<VOID: "void">
|	<STRUCT: "struct">
| 	<IF: "if">
| 	<ELSE: "else">
|	<WHILE: "while">
|	<FOR: "for">
|	<RETURN: "return">
|	<ALLOC: "alloc">
|	<ALLOC_ARRAY: "alloc_array">
|	<ROUNDEDBRACKT_O: "{"> //Enter code for depth of the blocks here
|	<ROUNDEDBRACKT_C: "}">
}

TOKEN : {
 <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
|  <#LETTER: ["$","A"-"Z","_","a"-"z"]>
|  <#DIGIT: ["0"-"9"]>
}

SKIP : { " " | "\t" | "\n" | "\r" | "\r\n" | "/*" : IN_COMMENT }
<IN_COMMENT> MORE : {	<~[]> | "*/" : DEFAULT }


void Parse(): {}
{
	(DeclarationsAndDefiniontions())* "##"
}

void DeclarationsAndDefiniontions(): {}
{
	LOOKAHEAD(3) //Otherwise possible conflict with a defintion of a function with return type struct
	<STRUCT> Sid() [<ROUNDEDBRACKT_O> Tp() Vid() <ROUNDEDBRACKT_C> ] ";"
|
	Tp() Vid() "(" Tp() Vid() ( "," Tp() Vid())* ")" (<ROUNDEDBRACKT_O> (Stmt())* <ROUNDEDBRACKT_C> | ";")
}

void Tp(): {}
{
	(<INT> | <BOOL> | <VOID> | <STRUCT> Sid()) ("*"|"[" "]")*
}

void Stmt(): {}
{
	Exp() ";"
|
	<IF> "(" Exp() ")" Stmt() [ LOOKAHEAD(2) <ELSE> Stmt() ]
|
	<WHILE> "(" Exp() ")" Stmt()
|
	<FOR> "(" [Exp()] ";" Exp() ";" [Exp()] ")" Stmt()
|
	<RETURN> [Exp()] ";"
|
	<ROUNDEDBRACKT_O> (Stmt())* <ROUNDEDBRACKT_C>
}

void Exp(): {}
{
	Tp() Vid() ["=" Exp()] //Variable definition
|
	<ALLOC> "(" Tp() ")"
|
	<ALLOC_ARRAY> "(" Tp() "," Exp() ")"
|
	Conditional() [Asnop() Exp()]
}

void Conditional(): {}
{
	LogicalOr() ["?" Conditional() ":" Conditional()]
}

void LogicalOr():{}
{
	LogicalAnd() ["||" LogicalOr()]
}

void LogicalAnd():{}
{
	BitwiseOr() ["&&" LogicalAnd()]
}

void BitwiseOr():{}
{
	BitwiseXOr() ["|" BitwiseOr()]
}

void BitwiseXOr():{}
{
	//Allow chains of xor, expression is calculated from right to left
	BitwiseAnd() ["^" BitwiseXOr()] 
}

void BitwiseAnd():{}
{
	Equality() ["&" BitwiseAnd()]
}

void Equality():{}
{
	/*
	 * Allow chains of equality, checked from right to left
	 * a==b==c==d is checked like a==(b==(c==d))
	 */
	Comparison() [("=="|"!=") Equality()] 
}

void Comparison():{}
{
	Shift() [("<"|"<="|">="|">") Comparison()]
}

void Shift():{}
{
	DashOprator() [(">>"|"<<") Shift()]
}

void DashOprator():{}
{
	PointOprator() [("+"|"-") DashOprator()]
}

void PointOprator():{}
{
	UnaryPreCalc() [("*"|"/"|"%") PointOprator()]
}

void UnaryPreCalc():{}
{
	[("!"|"~"|"-"|"*")]UnaryPostCalc()
}

void UnaryPostCalc():{}
{
	Parens()["++"|"--"]
}


void Parens():{}
{
	"(" Exp() ")"
|
	Vid() ("[" Exp() "]"
		  |"->" Fid()
		  |"."Fid())*
|
	//All the constant values go here
	<NUM> | <TRUE> | <FALSE> | <NULL>
}

//Assign operator
void Asnop(): {}
{
	( "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | "&=" | "^=" | "|=" )
}

//Struct names
void Sid(): {}
{
	<IDENTIFIER>
}

//Variable and function names
void Vid(): {}
{
	<IDENTIFIER>
}

// Field names
void Fid():{}
{
	<IDENTIFIER>
}