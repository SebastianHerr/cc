/**
 * C0-- Parser
 * HS-Fulda - Compiler Constructions
 *
 * @author    Konstantin Ruppel
 * @autor     Juergen Goebel
 * @autor     Sebastian Herr
 * 
 * @date      2017/06/03
 */

PARSER_BEGIN(C0)
public class C0 {
	public static void main(String args[]) {
		C0 parser;
    NodeRoot ast;
		try {
			if (args.length > 0) {
				parser = new C0 (new java.io.FileInputStream(new java.io.File(args[0])));
			} else {
				parser = new C0 (System.in);
			}
			ast = parser.Program();
      System.out.println(ast);
			System.out.println ("[  OK  ]");
		} catch (Exception ex) {
			System.out.println ("[ FAIL ]" + ((args.length > 1) ? ex.getMessage() + "\n\n" : ""));
		}
	}
}
PARSER_END(C0)

SKIP : 
{ 
  " " | "\t" | "\f" | "\n" | "\r" | "\r\n"
  |
  "/*" : IN_ML_COMMENT
  |
  < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >
}

<IN_ML_COMMENT> SKIP :
{
  <~[]>
  |
  "*/" : DEFAULT
}

// Keywords
TOKEN : {
	< INT:        	"int" >
	| < BOOLEAN:    "bool" >
	| < CHAR:       "char" >
	| < VOID:       "void" >
	| < STRUCT:     "struct" >
	| < IF:         "if" >
	| < ELSE:       "else" >
	| < WHILE:      "while" >
	| < FOR:        "for" >
	| < RETURN:     "return" >
	| < TRUE:       "true" >
	| < FALSE:      "false" >
	| < NULL:       "NULL" >
	| < ALLOC:      "alloc" >
  | < ALLOC_ARR:  "alloc_array" >
}

TOKEN : {
  < ID: <LETTER> ( <ALPHANUM> )* >
  |	< #LETTER: ["$","A"-"Z","a"-"z","_"] >
  |	< #ALPHANUM: ["$","A"-"Z","a"-"z","0"-"9","_"] >
  |	< NUM: <DECNUM> | <HEXNUM> >
  |	< DECNUM: "0" | ["1"-"9"](["0"-"9"])* >
  |	< HEXNUM: "0" ("x" | "X") (["0"-"9","a"-"f","A"-"F"])+ >
}

NodeRoot Program () : {NodeRoot root; Node declarationOrStatement;}
{
  {root = new NodeRoot();}
  ( 
    declarationOrStatement=Declaration_Definition()
    {root.addDeclarationOrStatement(declarationOrStatement);}
  )* 
  <EOF> {return root;}
}




Node Sid () : {Token name;}
{
   name=<ID> {return new NodeIdentifier(name);}   // struct name
}

Node Vid () : {Token name;}
{
   name=<ID> {return new NodeIdentifier(name);}   // variable and function name
}

Node Fid () : {Token name;}
{
  name=<ID> {return new NodeIdentifier(name);} // field name
}



Node Declaration_Definition () : {Node result = null; Node newNode; Node type; Node name;
  NodeStructSignature resultStructSig; NodeFunctionSignature resultFunctionSig;}
{
  (
  LOOKAHEAD (3)
	<STRUCT> name=Sid() {resultStructSig = new NodeStructSignature(name);}
    [ "{" {result = new NodeStructDefinition(resultStructSig);}
      ( type=Type() name=Vid() {((NodeStructDefinition)result).addElement(type, name);}";")* "}" 
    ] ";" {if(result == null) {result = new NodeStructDeclaration(resultStructSig);}}
	|
  type=Type() name=Vid() {resultFunctionSig = new NodeFunctionSignature(type, name);}
    "(" [ type=Type() name=Vid()  {resultFunctionSig.addParameter(type, name);}
      ( "," type=Type() name=Vid() {resultFunctionSig.addParameter(type, name);} )* ] ")" 
    ( newNode=Block() {result = new NodeFunctionDefinition(resultFunctionSig, newNode);}  | 
     ";"{result = new NodeFunctionDeclaration(resultFunctionSig);} )
  )
  {return result;}
}

Node Block() : {NodeBlock result; Node newNode;}
{
  {result = new NodeBlock();}
  "{" ( newNode=Statement() {result.addStatement(newNode);})* "}"
  {return result;}
}

Node Statement () : {Node result = null; NodeStatementIf resultIf;
  NodeStatementWhile resultWhile; NodeStatementFor resultFor;
  NodeStatementReturn resultReturn; Node newNode = null;}
{
  (
  newNode=Expression() ";" {result=new NodeStatementExpression(newNode);}
  |
	<IF> "(" newNode=Expression() {resultIf=new NodeStatementIf(newNode);}")" newNode=Statement() 
    {resultIf.setIf(newNode);}
    [ LOOKAHEAD(2) <ELSE> newNode=Statement() {resultIf.setElse(newNode); result=resultIf;}]
	|
	<WHILE> "(" newNode=Expression() {resultWhile=new NodeStatementWhile(newNode);}")" 
    newNode=Statement()
    {resultWhile.setLoopBody(newNode);result=resultWhile;}
	|
	<FOR> {resultFor=new NodeStatementFor();} 
    "(" [ newNode=Expression() {resultFor.setInitializer(newNode);}] 
    ";" Expression() {resultFor.setCondition(newNode);}
     ";" [ Expression() {resultFor.setIterator(newNode);}] 
    ")" newNode=Statement()
     {resultFor.setLoopBody(newNode);result=resultFor;}
	|
	<RETURN> {resultReturn=new NodeStatementReturn();}
    [ newNode=Expression() {resultReturn.setReturnValue(newNode);result=resultReturn;} ] ";"
	|
	result=Block() //No need to create a seperate statment block node, everything is already in the block
  )
  {return result;}
}

NodeMemberAccess MemberAccess () : {Node newNode; NodeMemberAccess memberaccess;}
{
  (
    "." newNode=Fid() {memberaccess= new NodeMemberAccessDot(newNode);}
    |
    "->" newNode=Fid() {memberaccess= new NodeMemberAccessArrow(newNode);}
    |
    "[" newNode=Expression() "]" {memberaccess= new NodeMemberAccessArray(newNode);}
  )
  [
    newNode=MemberAccess() {memberaccess.setAccessingNode(newNode);} 
  ]
  {return memberaccess;}
}

Node Type () : {Node result; Node newNode;Token token;}
{
	(
		token=<INT> {result= new NodeTypeInt(token);} 
    | 
    token=<BOOLEAN> {result= new NodeTypeBool(token);}
    | 
    token=<VOID>{result= new NodeTypeVoid(token);}
		|
		token=<STRUCT> newNode=Sid() {result = new NodeTypeStruct(newNode);}
	)
	( 
		"*" {result = new NodeTypePointer(result);}| "[" "]"{result = new NodeTypeArray(result);}
	)*
  {return result;}
}

NodeFunctionCallArgs FunctionCallArgs () : {NodeFunctionCallArgs result; Node newNode;}
{
  {result = new NodeFunctionCallArgs();}
  [ newNode=Expression() {result.addArg(newNode);}
    ("," newNode=Expression() {result.addArg(newNode);})* 
  ]
  {return result;}
}

Node Expression () : {Node result; Node array_alloc_size; 
  Node type; Node name; Node newNode; NodeExpressionAssign resultAssign;}
{	
  <ALLOC> "(" result=Type() ")" {return new NodeExpressionAlloc(result);}
  |
  <ALLOC_ARR> "(" result=Type() "," array_alloc_size=Expression() ")" 
    {return new NodeExpressionAllocArray(result,array_alloc_size);}
  |
  result=OpRang_Assign() {return result;}
  |
  type=Type() name=Vid() {result = new NodeExpressionVariableDefinition(type,name);}
    [ LOOKAHEAD(2) {resultAssign= new NodeExpressionAssign(result); resultAssign.setOp("=");} 
      "=" newNode=OpRang_Conditional() {resultAssign.setSecondary(newNode);result=resultAssign;}]
    {return result;}
}

Node OpRang_Assign () : {Node result; NodeExpressionAssign resultAssign;}
{
  result=OpRang_Conditional()
  [ 
    LOOKAHEAD(2)
    {resultAssign= new NodeExpressionAssign(result);}
    (
      "="  {resultAssign.setOp("=")  ;}| 
      "+=" {resultAssign.setOp("+=") ;}| 
      "-=" {resultAssign.setOp("-=") ;}| 
      "*=" {resultAssign.setOp("*=") ;}| 
      "/=" {resultAssign.setOp("/=") ;}| 
      "%=" {resultAssign.setOp("%=") ;}| 
      "<<="{resultAssign.setOp("<<=");}| 
      ">>="{resultAssign.setOp(">>") ;}| 
      "&=" {resultAssign.setOp("&=") ;}| 
      "^=" {resultAssign.setOp("^=") ;}| 
      "|=" {resultAssign.setOp("|=") ;}
    ) 
    result=OpRang_Conditional() {resultAssign.setSecondary(result);result=resultAssign;}
  ]
  {return result;}
}

Node OpRang_Conditional () : {Node result; NodeStatementIf resultIf;}
{
  //Using the normal If Node since this here is just a shorthand for the normal if then else construct
  result=OpRang_LogicalOr() 
  [ LOOKAHEAD(2)  
    ( "?" {resultIf=new NodeStatementIf(result);} result=Expression() {resultIf.setIf(result);}
      ":" result=Expression() {resultIf.setElse(result); result = resultIf;}) 
  ]
  {return result;}
}

Node OpRang_LogicalOr () : {Node result; NodeExpressionBinary resultBin;}
{
  result=OpRang_LogicalAnd() [ {resultBin = new NodeExpressionLogicalOr(result);} 
        ( "||" ) result=OpRang_LogicalOr()  {resultBin.setSecondary(result);result=resultBin;}]
  {return result;}
}

Node OpRang_LogicalAnd () : {Node result;NodeExpressionBinary resultBin;}
{
  result=OpRang_BitOr() [ {resultBin = new NodeExpressionLogicalAnd(result);} 
        ( "&&" ) result=OpRang_LogicalAnd()  {resultBin.setSecondary(result);result=resultBin;}]
  {return result;}
}

Node OpRang_BitOr () : {Node result;NodeExpressionBinary resultBin;}
{
  result=OpRang_BitXor() [ {resultBin = new NodeExpressionBitOr(result);} 
        ( "|" ) result=OpRang_BitOr()  {resultBin.setSecondary(result);result=resultBin;}]
  {return result;}
}

Node OpRang_BitXor () : {Node result;NodeExpressionBinary resultBin;}
{
  result=OpRang_BitAnd() [ {resultBin = new NodeExpressionBitXor(result);} 
        ( "^" ) result=OpRang_BitXor()  {resultBin.setSecondary(result);result=resultBin;}]
  {return result;}
}

Node OpRang_BitAnd () : {Node result;NodeExpressionBinary resultBin;}
{
  result=OpRang_Equality() [ {resultBin = new NodeExpressionBitAnd(result);} 
        ( "&" ) result=OpRang_BitAnd() {resultBin.setSecondary(result);result=resultBin;} ]
  {return result;}
}

Node OpRang_Equality () : {Node result;NodeExpressionBinary resultBin;}
{
  result=OpRang_Compare() [ {resultBin = new NodeExpressionEquality(result);} 
        ( "==" {resultBin.setOp("==");}| 
          "!=" {resultBin.setOp("!=");}) 
        result=OpRang_Equality() {resultBin.setSecondary(result);result=resultBin;}]
 {return result;}
}

Node OpRang_Compare () : {Node result;NodeExpressionBinary resultBin;}
{
  result=OpRang_BitShift() [ {resultBin = new NodeExpressionCompare(result);} 
        ( "<" {resultBin.setOp("<");}| 
          ">" {resultBin.setOp(">");}| 
          ">=" {resultBin.setOp(">=");}| 
          "<=" {resultBin.setOp("<=");}) 
        result=OpRang_Compare() {resultBin.setSecondary(result);result=resultBin;}]
  {return result;}
}

Node OpRang_BitShift () : {Node result;NodeExpressionBinary resultBin;}
{
  result=OpRang_Sum() [ {resultBin = new NodeExpressionBitShift(result);} 
        ( "<<" {resultBin.setOp("<<");}| 
          ">>" {resultBin.setOp(">>");}) 
        result=OpRang_BitShift() {resultBin.setSecondary(result);result=resultBin;}]
  {return result;}
}

Node OpRang_Sum () : {Node result;NodeExpressionBinary resultBin;}
{
  result=OpRang_Factor() [ {resultBin = new NodeExpressionSum(result);} 
        ( "+" {resultBin.setOp("+");}| 
          "-" {resultBin.setOp("-");}) 
        result=OpRang_Sum() {resultBin.setSecondary(result);result=resultBin;}]
  {return result;}
}

Node OpRang_Factor () : {Node result; Node newNode;NodeExpressionBinary resultBin;}
{
  result=OpRang_Unary() [ {resultBin = new NodeExpressionFactor(result);} 
        ("*" {resultBin.setOp("*");} |
         "/" {resultBin.setOp("/");} | 
         "%" {resultBin.setOp("%");} ) 
         newNode=OpRang_Factor() {resultBin.setSecondary(newNode);result=resultBin;}] 
  {return result;}
}

Node OpRang_Unary () : {NodeExpressionUnary unaryOp = null; Node result; 
  NodeMemberAccess memberaccess = null; NodeFunctionCallArgs functionArgs; Token token;}
{
  //gather information for this node...
  [
    "*" {unaryOp=new NodeExpressionUnaryDereference();} | 
    "-" {unaryOp=new NodeExpressionUnaryMinus();} | 
    "~" {unaryOp=new NodeExpressionUnaryBitwiseNegation();} |
    "!" {unaryOp=new NodeExpressionUnaryNegation();}
  ]
  (
    result=Vid() [ "(" functionArgs=FunctionCallArgs() ")" 
                    {result = new NodeExpressionFunctionCall(result, functionArgs);} 
                 | 
                   "--" { result = new NodeExpressionDecrement(result);}
                 | 
                   "++" { result = new NodeExpressionIncrement(result);}
                 ]
    |
      token=<NUM>  {result= new NodeExpressionConstNum(token);}	
    | 
      token=<TRUE> {result= new NodeExpressionConstTrue(token);} 
    | 
      token=<FALSE>{result= new NodeExpressionConstFalse(token);} 
    | 
      token=<NULL> {result= new NodeExpressionConstNull(token);}
    |
    "(" result=OpRang_Conditional() ")"
  )
  [
    /*
     * If there is a constant or function before that, then the type checker will complain here,
     * unless the returned item is a stack or something :)
     */
    memberaccess=MemberAccess()
  ]
  //...and assemble it
  {
    if(memberaccess != null)
    { memberaccess.setAccessingNode(result); result=memberaccess; }
    if(unaryOp != null)
    { unaryOp.setInternNode(result); result=unaryOp; }
    return result;
  }
}