/**
 * C0-- Parser
 * HS-Fulda - Compiler Constructions
 *
 * @author    Konstantin Ruppel
 * @autor     Juergen Goebel
 * @autor     Sebastian Herr
 * 
 * @date      2017/06/01
 */

options
{
  DEBUG_PARSER = true;
  DEBUG_TOKEN_MANAGER = true;
}

PARSER_BEGIN(C0)
public class C0 {
	static boolean x = true;
	public static void main(String args[]) {
		C0 parser;
		try {
			if (args.length > 0) {
				parser = new C0 (new java.io.FileInputStream(new java.io.File(args[0])));
			} else {
				parser = new C0 (System.in);
			}
			parser.Program();
			System.out.println ("[  OK  ]");
		} catch (Exception ex) {
			System.out.println ("[ FAIL ]\n\n" + ex.getMessage());
		}
	}
}
PARSER_END(C0)

SKIP : 
{ 
  " " | "\t" | "\f" | "\n" | "\r" | "\r\n"
  |
  "/*" : IN_ML_COMMENT
}

<IN_ML_COMMENT> SKIP :
{
  <~[]>
  |
  "*/" : DEFAULT
}

SPECIAL_TOKEN : 
{
  < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >
}

// Keywords
TOKEN : {
	< INT:        	"int" >
	| < BOOLEAN:    "bool" >
	| < CHAR:       "char" >
	| < VOID:       "void" >
	| < STRUCT:     "struct" >
	| < IF:         "if" >
	| < ELSE:       "else" >
	| < WHILE:      "while" >
	| < FOR:        "for" >
	| < RETURN:     "return" >
	| < TRUE:       "true" >
	| < FALSE:      "false" >
	| < NULL:       "NULL" >
	| < ALLOC:      "alloc" >
  | < ALLOC_ARR:  "alloc_array" >
}

TOKEN : {
	< ID: <LETTER> ( <ALPHANUM> )* >
	|	< #LETTER: ["$","A"-"Z","a"-"z","_"] >
	|	< #ALPHANUM: ["$","A"-"Z","a"-"z","0"-"9","_"] >
	|	< NUM: <DECNUM> | <HEXNUM> >
	|	< DECNUM: "0" | ["1"-"9"](["1"-"9"])* >
	|	< HEXNUM: "0" ("x" | "X") (["0"-"9","a"-"f","A"-"F"])+ >
}

void Program () : {}
{
	( 
    Declaration_Definition()
  )* 
  <EOF>
}

void Sid () : {}
{
  <ID>  // struct name
}

void Vid () : {}
{
  <ID>  // variable and function name
}

void Fid () : {}
{
  <ID>  // field name
}

/*
<gdecl>     ::= struct <sid> ; 
            | <tp> <vid> ( [<tp> <vid> (, <tp> <vid>)*] ) ; 
<gdefn>     ::= struct <sid> { (<tp> <fid> ;)* } ; 
            | <tp> <vid> ( [<tp> <vid> (, <tp> <vid>)*] ) { <stmt>* }
*/
void Declaration_Definition () : {}
{
  LOOKAHEAD (3)
	<STRUCT> Sid() [ "{" ( Type() Vid() ";" )* "}" ] ";"
	|
  Type() Vid() "(" [ Type() Vid() ( "," Type() Vid() )* ] ")" ( "{" ( Statement() )* "}" | ";" )
}

/*
<stmt>      ::= <simple> ;
            | if ( <exp> ) <stmt> [else <stmt>]
            | while ( <exp> ) <stmt>
            | for ( [<simple>] ; <exp> ; [<simple>] ) <stmt>
            | return [<exp>] ;
            | { <stmt>* }
*/
void Statement () : {}
{
  Simple() ";"
  |
	<IF> "(" Expression() ")" Statement() [ LOOKAHEAD(2) <ELSE> Statement() ]
	|
	<WHILE> "(" Expression() ")" Statement()
	|
	<FOR> "(" [ Simple() ] ";" Expression() ";" [ Simple() ] ")" Statement()
	|
	<RETURN> [ Expression() ] ";"
	|
	"{" ( Statement() )* "}"
}

/*
<simple>    ::= <lv> <asnop> <exp>
            | <lv> ++ 
            | <lv> --
            | <exp> 
            | <tp> <vid> [= <exp>]
*/
void Simple () : {}
{
	LOOKAHEAD(3) AssignOperation()
	|
	LOOKAHEAD(2) MemberAccess() ( "++" | "--" ) 
	|
	Expression()
	|
	Type() Vid() [ "=" Expression() ]
}

/*
Part of Simple()
*/
void AssignOperation () : {}
{
	( MemberAccess() )
	( "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | "&=" | "^=" | "|=" )
	( Expression() )
}

/*
<lv>        ::= <vid> 
            | * <lv> 
            | ( <lv> )
            | <lv> [ <exp> ] 
            | <lv> . <fid> 
            | <lv> -> <fid> 
*/
void MemberAccess () : {}
{
	(
		Vid()
		|	
		"*" MemberAccess()
		|	
		"(" MemberAccess() ")"
	)
  [ LOOKAHEAD(2)
    (
      "." Fid()
      |
      "->" Fid()
      |
      "[" Expression() "]"
    )
    [
      MemberAccess()
    ]
  ]
}

/*
<tp>        ::= int
            | bool
            | string
            | char
            | void
            | <tp> *
            | <tp> [ ]
            | struct <sid>
*/
void Type () : {}
{
	(
		<INT> | <BOOLEAN> | <CHAR> | <VOID>
		|
		<STRUCT> Sid()
	)
	( 
		"*" | "[" "]"
	)*
}

/*
<exp>       ::= ( <exp> ) 
            | <num> 
            | true 
            | false 
            | NULL 
            | <vid> 
            | <vid> ( [<exp> (, <exp>)*] ) 
            | <unop> <exp> 
            | alloc ( <tp> ) 
            | alloc_array ( <tp> , <exp> )
            | <exp> <binop> <exp> 
            | <exp> ? <exp> : <exp> 
            | <exp> . <fid> 
            | <exp> -> <fid> 
            | <exp> [ <exp> ]
*/
void Expression () : {}
{	
  (
    <ALLOC> "(" Type() ")"
    |
    <ALLOC_ARR> "(" Type() "," Expression() ")"
    |
    <NUM>	| <TRUE> | <FALSE> | <NULL>
    |
    "(" Expression() ")"
    |
    LOOKAHEAD(2) Vid() "(" [ Expression() ("," Expression() )* ] ")"
    |
    Vid()
    |
    UnOp() Expression()
  )
  [ LOOKAHEAD(2)
    (
      BinOp() Expression()
      |
      "?" Expression() ":" Expression()
      |
      "." Fid()
      |
      "->" Fid()
      |
      "[" Expression() "]"
    )
    [ LOOKAHEAD(2)
      Expression()
    ]
  ]
}

void  BinOp () : {}
{
  ( "||" )
  |
  ( "&&" )
  |
  ( "|" )
  |
  ( "^" )
  |
  ( "&" )
  |
  ( "==" | "!=" )
  |
  ( "<" | "<=" | ">=" | ">" )
  |
  ( "<<" | ">>" )
  |
  ( "+" | "-" )
  |
  ( "*" | "/" | "%" )
}

void UnOp () : {}
{
  "*" | "-" | "~" | "!"
}
