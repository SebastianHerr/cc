/**
 * C0-- Parser
 * HS-Fulda - Compiler Constructions
 *
 * @author    Konstantin Ruppel
 * @autor     Juergen Goebel
 * @autor     Sebastian Herr
 * 
 * @date      2017/06/03
 */

PARSER_BEGIN(C0)
/**
 * This class allows you creating Nodes, adding children and printing
 * them to the console in a hierarchical way.
 *
 * @name Node
 * @author Konstantin Ruppel
 */
class Node {

  public static String standardIndentation = ". ";
  String image = null;
  Node parent = null;
  Node child = null;
  Node sibling = null;

  // Position in source file
  int beginLine;
  int beginColumn;
  int endLine;
  int endColumn;

  public Node (String image) {
    this.image = image;
  }

  public Node (Token token) {
    this.image = token.image;
    this.beginLine = token.beginLine;
    this.beginColumn = token.beginColumn;
    this.endColumn = token.endColumn;
    this.endLine = token.endLine;
  }

  public Node (Token token, Node parent) {
    this (token);
    parent.addChild (this);
  }

  /***************************************************************************/

  /**
   * Adds a new child. If this is not the first child, it will become a sibling
   * of the child or the siblings sibling of the child and so on.
   * @param child Child node.
   */
  public void addChild (Node child) {
    if (this.child == null) {
      this.child = child;
      this.child.parent = this;
    } else {
      this.child.addSibling (child);
    }
  }

  /**
   * Appends a new child node representing the given value.
   * @param value String representation of this node.
   */
  public void addChild (Token token) {
    addChild (new Node(token));
  }

  /**
   * Adds a new sibling and sets its parent to the current Nodes parent.
   * @param sibling Sibling node.
   */
  public void addSibling (Node sibling) {
    if (this.sibling == null) {
      this.sibling = sibling;
      this.sibling.parent = this.parent;
    } else {
      this.sibling.addSibling (sibling);
    }
  }

  /***************************************************************************/

  /**
   * Prints the branch outgoing from this node to the console.
   * @param indentation Indentation on each layer.
   */
  public void printTree (String indentation) {
    System.out.println (indentation + this.image);
    if (this.child != null) {
      this.child.printTree (standardIndentation + indentation);
    }
    if (this.sibling != null) {
      this.sibling.printTree (indentation);
    }
  }

  /**
   * Calls printTree with no indentation for the starting node.
   */
  public void printTree () {
    printTree("");
  }

  /**
   * Gets the root node recursively.
   * @return Root node.
   */
  public Node getRoot () {
    if (this.parent == null) {
      return this;
    } else {
      return this.parent.getRoot();
    }
  }

  @Override
  public String toString () {
    return this.image;
  }
}



public class C0 {
  static boolean x = true;
  public static void main(String args[]) {
    C0 parser;
    try {
      if (args.length > 0) {
        parser = new C0 (new java.io.FileInputStream(new java.io.File(args[0])));
      } else {
        parser = new C0 (System.in);
      }
      Node root = parser.Program();
      if (args.length > 1) root.printTree();
      System.out.println ("[  OK  ]");
    } catch (Exception ex) {
      System.out.println ("[ FAIL ]");
    }
  }
}
PARSER_END(C0)

SKIP : 
{ 
  " " | "\t" | "\f" | "\n" | "\r" | "\r\n"
  |
  "/*" : IN_ML_COMMENT
  |
  < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >
}

<IN_ML_COMMENT> SKIP :
{
  <~[]>
  |
  "*/" : DEFAULT
}

// Keywords
TOKEN : {
  < INT:        	"int" >
  | < BOOLEAN:    "bool" >
  | < CHAR:       "char" >
  | < VOID:       "void" >
  | < STRUCT:     "struct" >
  | < IF:         "if" >
  | < ELSE:       "else" >
  | < WHILE:      "while" >
  | < FOR:        "for" >
  | < RETURN:     "return" >
  | < TRUE:       "true" >
  | < FALSE:      "false" >
  | < NULL:       "NULL" >
  | < ALLOC:      "alloc" >
  | < ALLOC_ARR:  "alloc_array" >
}

TOKEN : {
  < ID: <LETTER> ( <ALPHANUM> )* >
  |	< #LETTER: ["$","A"-"Z","a"-"z","_"] >
  |	< #ALPHANUM: ["$","A"-"Z","a"-"z","0"-"9","_"] >
  |	< NUM: <DECNUM> | <HEXNUM> >
  |	< DECNUM: "0" | ["1"-"9"](["0"-"9"])* >
  |	< HEXNUM: "0" ("x" | "X") (["0"-"9","a"-"f","A"-"F"])+ >
}

Node Program () : { Node me = new Node("Program"); Node decl; Token t = null; }
{
  ( 
    decl = Declaration_Definition() {me.addChild(decl);}
  )* 
  t = <EOF> {me.addChild(t);}
  
  {
    return me;
  }
}

Node Sid () : { Node me = new Node("Sid"); Token t; }
{
  t = <ID> {me.addChild(t);}
  {
    return me;
  }
}

Node Vid () : { Node me = new Node("Vid"); Token t; }
{
  t = <ID> {me.addChild(t);}
  {
    return me;
  }
}

Node Fid () : { Node me = new Node("Fid"); Token t; }
{
  t = <ID> {me.addChild(t);}
  {
    return me;
  }
}

Node Declaration_Definition () : { Node me = new Node("Declaration_Definition"); Node sid, type, vid, stat; Token t; }
{
  (
    LOOKAHEAD (3)
    t = <STRUCT> {me.addChild(t);}
    sid = Sid() {me.addChild(sid);}
    [ 
      t = "{" {me.addChild(t);}
      ( 
        type = Type() {me.addChild(type);}
        vid = Vid() {me.addChild(vid);}
        t = ";" {me.addChild(t);}
      )* 
      t = "}" {me.addChild(t);}
    ] 
    t = ";" {me.addChild(t);}
    |
    type = Type() {me.addChild(type);}
    vid = Vid() {me.addChild(vid);}
    t = "(" {me.addChild(t);}
    [ 
      type = Type() {me.addChild(type);}
      vid = Vid() {me.addChild(vid);}
      ( 
        t = "," {me.addChild(t);}
        type = Type() {me.addChild(type);}
        vid = Vid() {me.addChild(vid);}
      )*
    ] 
    t = ")" {me.addChild(t);}
    ( 
      t = "{" {me.addChild(t);}
      ( 
        stat = Statement() {me.addChild(stat);}
      )* 
      t = "}" {me.addChild(t);}
      |
      t = ";" {me.addChild(t);}
    )
  )
  {
    return me;
  }
}

Node Statement () : { Node me = new Node("Statement"); Node exp1, exp2, exp3, stat1, stat2; Token t; }
{
  (
    exp1= Expression() {me.addChild(exp1);}
    t = ";" {me.addChild(t);}
    |
    t = <IF> {me.addChild(t);}
    t = "(" {me.addChild(t);}
    exp1 = Expression() {me.addChild(exp1);}
    t = ")" {me.addChild(t);}
    stat1 = Statement() {me.addChild(stat1);}
    [ 
      LOOKAHEAD(2) 
      t = <ELSE> {me.addChild(t);}
      stat2 = Statement() {me.addChild(stat2);}
    ]
    |
    t = <WHILE> {me.addChild(t);}
    t = "(" {me.addChild(t);}
    exp1 = Expression() {me.addChild(exp1);}
    t = ")" {me.addChild(t);}
    stat1 = Statement() {me.addChild(stat1);}
    |
    t = <FOR> {me.addChild(t);}
    t = "(" {me.addChild(t);}
    [ 
      exp1 = Expression() {me.addChild(exp1);}
    ] 
    t = ";" {me.addChild(t);}
    exp2= Expression() {me.addChild(exp2);}
    t = ";" {me.addChild(t);}
    [ 
      exp3 = Expression() {me.addChild(exp3);}
    ] 
    t = ")" {me.addChild(t);}
    stat1 = Statement() {me.addChild(stat1);}
    |
    <RETURN> {me.addChild(t);}
    [ 
      exp1 = Expression() {me.addChild(exp1);}
    ] 
    t = ";" {me.addChild(t);}
    |
    t = "{" {me.addChild(t);}
    ( 
      stat1 = Statement() {me.addChild(stat1);}
    )* 
    t = "}" {me.addChild(t);}
  )
  {
    return me;
  }
}

Node MemberAccess () : { Node me = new Node("MemberAccess"); Node fid1, fid2, exp, macc; Token t; }
{
  (
    t = "." {me.addChild(t);}
    fid1 = Fid() {me.addChild(fid1);}
    |
    t = "->" {me.addChild(t);}
    fid2 = Fid() {me.addChild(fid2);}
    |
    t = "[" {me.addChild(t);}
    exp = Expression() {me.addChild(exp);}
    t = "]" {me.addChild(t);}
  )
  [
    macc = MemberAccess() {me.addChild(macc);}
  ]
  {
    return me;
  }
}

Node Type () : { Node me = new Node("Type"); Node sid; Token t; }
{
  (
    t = <INT> {me.addChild(t);}
    | 
    t = <BOOLEAN> {me.addChild(t);}
    | 
    t = <CHAR> {me.addChild(t);}
    | 
    t = <VOID> {me.addChild(t);}
    |
    t = <STRUCT> {me.addChild(t);}
    sid = Sid() {me.addChild(sid);}
  )
  (
    t = "*" {me.addChild(t);}
    | 
    t = "[" {me.addChild(t);}
    t = "]" {me.addChild(t);}
  )*
  {
    return me;
  }
}

Node FunctionCallArgs () : { Node me = new Node("FunctionCallArgs"); Node exp1, exp2; Token t; }
{
  [
    exp1 = Expression() {me.addChild(exp1);}
    (
      t = "," {me.addChild(t);}
      exp2 = Expression() {me.addChild(exp2);}
    )*
  ]
  {
    return me;
  }
}

Node Expression () : { Node me = new Node("Expression"); Node type, exp, ass, vid, cond; Token t; }
{
  (
    t = <ALLOC> {me.addChild(t);}
    t = "(" {me.addChild(t);}
    type = Type() {me.addChild(type);}
    t = ")" {me.addChild(t);}
    |
    t = <ALLOC_ARR> {me.addChild(t);} 
    t = "(" {me.addChild(t);}
    type = Type() {me.addChild(type);}
    t = "," {me.addChild(t);}
    exp = Expression() {me.addChild(exp);}
    t = ")" {me.addChild(t);}
    |
    ass = OpRang_Assign() {me.addChild(ass);}
    |
    type = Type() {me.addChild(type);}
    vid = Vid() {me.addChild(vid);}
    [ 
      LOOKAHEAD(2)
      t = "=" {me.addChild(t);}
      cond = OpRang_Conditional() {me.addChild(cond);} 
    ]
  )
  {
    return me;
  }
}

Node OpRang_Assign () : { Node me = new Node("OpRang_Assign"); Node cond1, cond2; Token t; }
{
  cond1 = OpRang_Conditional() {me.addChild(cond1);}
  [ 
    LOOKAHEAD(2)
    (
      t = "=" {me.addChild(t);}
      | 
      t = "+=" {me.addChild(t);}
      | 
      t = "-=" {me.addChild(t);}
      | 
      t = "*=" {me.addChild(t);}
      | 
      t = "/=" {me.addChild(t);}
      | 
      t = "%=" {me.addChild(t);}
      | 
      t = "<<=" {me.addChild(t);}
      | 
      t = ">>=" {me.addChild(t);}
      | 
      t = "&=" {me.addChild(t);}
      | 
      t = "^=" {me.addChild(t);}
      | 
      t = "|=" {me.addChild(t);}
    )
    cond2 = OpRang_Conditional() {me.addChild(cond2);}
  ]
  {
    return me;
  }
}

Node OpRang_Conditional () : { Node me = new Node("OpRang_Conditional"); Node or, exp1, exp2; Token t; }
{
  or = OpRang_LogicalOr() {me.addChild(or);}
  [ 
    LOOKAHEAD(2) 
    ( 
      t = "?" {me.addChild(t);}
      exp1 = Expression() {me.addChild(exp1);}
      t = ":" {me.addChild(t);}
      exp2 = Expression() {me.addChild(exp2);}
    )
  ]
  {
    return me;
  }
}

Node OpRang_LogicalOr () : { Node me = new Node("OpRang_LogicalOr"); Node and, or; Token t = null; }
{
  and = OpRang_LogicalAnd() {me.addChild(and);}
  [
    (
      t = "||" {me.addChild(t);}
    ) 
    or = OpRang_LogicalOr() {me.addChild(or);}
  ]
  {
    return me;
  }
}

Node OpRang_LogicalAnd () : { Node me = new Node("OpRang_LogicalAnd"); Node or, and; Token t; }
{
  or = OpRang_BitOr() {me.addChild(or);}
  [ 
    ( 
      t = "&&" {me.addChild(t);}
    ) 
    and = OpRang_LogicalAnd() {me.addChild(and);}
  ]
  {
    return me;
  }
}

Node OpRang_BitOr () : { Node me = new Node("OpRang_BitOr"); Node xor, or; Token t; }
{
  xor = OpRang_BitXor() {me.addChild(xor);}
  [ 
    (
      t = "|" {me.addChild(t);}
    ) 
    or = OpRang_BitOr() {me.addChild(or);}
  ]
  {
    return me;
  }
}

Node OpRang_BitXor () : { Node me = new Node("OpRang_BitXor"); Node and, xor; Token t; }
{
  and = OpRang_BitAnd() {me.addChild(and);}
  [ 
    ( 
      t = "^" {me.addChild(t);}
    ) 
    xor = OpRang_BitXor() {me.addChild(xor);}
  ]
  {
    return me;
  }
}

Node OpRang_BitAnd () : { Node me = new Node("OpRang_BitAnd"); Node equ, and; Token t; }
{
  equ = OpRang_Equality() {me.addChild(equ);}
  [ 
    ( 
      t = "&" {me.addChild(t);}
    ) 
    and = OpRang_BitAnd() {me.addChild(and);}
  ]
  {
    return me;
  }
}

Node OpRang_Equality () : { Node me = new Node("OpRang_Equality"); Node comp, equ; Token t; }
{
  comp = OpRang_Compare() {me.addChild(comp);}
  [ 
    ( 
      t = "==" {me.addChild(t);}
      | 
      t = "!=" {me.addChild(t);}
    ) 
    equ = OpRang_Equality() {me.addChild(equ);}
  ]
  {
    return me;
  }
}

Node OpRang_Compare () : { Node me = new Node("OpRang_Compare"); Node shift, comp; Token t; }
{
  shift = OpRang_BitShift() {me.addChild(shift);}
  [ 
    ( 
      t = "<" {me.addChild(t);}
      | 
      t = ">" {me.addChild(t);}
      | 
      t = ">=" {me.addChild(t);}
      | 
      t = "<=" {me.addChild(t);}
    ) 
    comp = OpRang_Compare() {me.addChild(comp);}
  ]
  {
    return me;
  }
}

Node OpRang_BitShift () : { Node me = new Node("OpRang_BitShift"); Node sum, shift; Token t; }
{
  sum = OpRang_Sum() {me.addChild(sum);} 
  [ 
    (
      t = "<<" {me.addChild(t);} 
      |
      t = ">>" {me.addChild(t);}
    ) 
    shift = OpRang_BitShift() {me.addChild(shift);} 
  ]
  {
    return me;
  }
}

Node OpRang_Sum () : { Node me = new Node("OpRang_Sum"); Node fac, sum; Token t; }
{
  fac = OpRang_Factor() {me.addChild(fac);}
  [ 
    (
      t = "+" {me.addChild(t);}
      | 
      t = "-" {me.addChild(t);}
    ) 
    sum = OpRang_Sum() {me.addChild(sum);}
  ]
  {
    return me;
  }
}

Node OpRang_Factor () : { Node me = new Node("OpRang_Factor"); Node unary, fac; Token t; }
{
  unary = OpRang_Unary() {me.addChild(unary);} 
  [ 
    (
      t = "*" {me.addChild(t);}
      | 
      t = "/" {me.addChild(t);}
      | 
      t = "%" {me.addChild(t);}
    ) 
    fac = OpRang_Factor() {me.addChild(fac);}
  ]
  {
    return me;
  }
}

Node OpRang_Unary () : { Node me = new Node("OpRang_Unary"); Node fnCallArgs, vid, cond, macc; Token t; }
{
  [
    t = "*" {me.addChild(t);}
    | 
    t = "-" {me.addChild(t);}
    | 
    t = "~" {me.addChild(t);}
    | 
    t = "!" {me.addChild(t);}
  ]
  (
    vid = Vid() {me.addChild(vid);}
    [
      t = "(" {me.addChild(t);}
      fnCallArgs = FunctionCallArgs() {me.addChild(fnCallArgs);}
      t = ")" {me.addChild(t);}
      | 
      t = "--" {me.addChild(t);}
      | 
      t = "++" {me.addChild(t);}
    ]
    |
    t = <NUM> {me.addChild(t);}
    | 
    t = <TRUE> {me.addChild(t);} 
    | 
    t = <FALSE> {me.addChild(t);} 
    | 
    t = <NULL> {me.addChild(t);}
    |
    t = "(" {me.addChild(t);}
    cond = OpRang_Conditional() {me.addChild(cond);}
    t = ")" {me.addChild(t);}
  )
  [
    macc = MemberAccess() {me.addChild(macc);}
  ]
  {
    return me;
  }
}