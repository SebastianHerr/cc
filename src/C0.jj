/**
 * C0-- Parser
 * HS-Fulda - Compiler Constructions
 *
 * @author    Konstantin Ruppel
 * @author    Juergen Goebel
 * @author    Sebastian Herr
 * 
 * @date      2017/06/03
 */

PARSER_BEGIN(C0)
import java.util.*;
public class C0 {
  
  static Stack<IScope> scope;
  static SymbolTable vidTable;
  static SymbolTable sidTable;
  static SymbolTable fidTable;
  
	public static void main(String args[]) {
		C0 parser;
    NodeRoot ast;  
    scope = new Stack<IScope>();
    vidTable = new SymbolTable();
    sidTable = new SymbolTable();
    fidTable = new SymbolTable();
		try {
			if (args.length > 0) {
				parser = new C0 (new java.io.FileInputStream(new java.io.File(args[0])));
			} else {
				parser = new C0 (System.in);
			}
			ast = parser.Program();
      System.out.println ("/*");
      System.out.println ("Stats of vidTable");
      vidTable.printStats();
      System.out.println ("Stats of sidTable");
      sidTable.printStats();
      System.out.println ("Stats of fidTable");
      fidTable.printStats();
      System.out.println (" */");
      System.out.println(ast);
			System.out.println ("[  OK  ]");
		} catch (Exception ex) {
			System.out.println ("[ FAIL ]" + ((args.length > 1) ? ex.getMessage() + "\n\n" : ""));
		}
	}
}
PARSER_END(C0)

TOKEN_MGR_DECLS:
{
  static int commentDepth;
}

SKIP : 
{ 
  " " | "\t" | "\f" | "\n" | "\r" | "\r\n"
  |
  "/*" {commentDepth = 1;} : IN_ML_COMMENT
  |
  < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >
}

/*
 * Allowing for nested multiline comments
 * Implementation from Introduction to "Compiler Construction in a Java World" page 56
 */
<IN_ML_COMMENT> SKIP :
{
  <~[]>
  |
  "*/" {commentDepth -= 1; SwitchTo( commentDepth == 0 ? DEFAULT : IN_ML_COMMENT);}
  |
  "/*" {commentDepth += 1;}
}

// Keywords
TOKEN : {
	< INT:        	"int" >
	| < BOOLEAN:    "bool" >
	| < CHAR:       "char" >
	| < VOID:       "void" >
	| < STRUCT:     "struct" >
	| < IF:         "if" >
	| < ELSE:       "else" >
	| < WHILE:      "while" >
	| < FOR:        "for" >
	| < RETURN:     "return" >
	| < TRUE:       "true" >
	| < FALSE:      "false" >
	| < NULL:       "NULL" >
	| < ALLOC:      "alloc" >
  | < ALLOC_ARR:  "alloc_array" >
}

TOKEN : {
  < ID: <LETTER> ( <ALPHANUM> )* >
  |	< #LETTER: ["$","A"-"Z","a"-"z","_"] >
  |	< #ALPHANUM: ["$","A"-"Z","a"-"z","0"-"9","_"] >
  |	< NUM: <DECNUM> | <HEXNUM> >
  |	< DECNUM: "0" | ["1"-"9"](["0"-"9"])* >
  |	< HEXNUM: "0" ("x" | "X") (["0"-"9","a"-"f","A"-"F"])+ >
}

NodeRoot Program () : {NodeRoot root = new NodeRoot(); Node node;}
{
  {scope.push(root);}
  
  (
    ( 
      node = Declaration_Definition() {root.addDeclarationOrStatement(node);}
    )* 
    <EOF> 
  )

  {scope.pop(); return root;}
}

Node Sid () : {Token name; NodeIdentifier node;}
{
   name = <ID> {node = new NodeIdentifier(name); sidTable.addSymbol(node, scope.peek()); return node;}   // struct name
}

Node Vid () : {Token name; NodeIdentifier node;}
{
   name = <ID> {node = new NodeIdentifier(name); vidTable.addSymbol(node, scope.peek()); return node;}   // variable and function name
}

Node Fid () : {Token name; NodeIdentifier node;}
{
  name = <ID> {node = new NodeIdentifier(name); fidTable.addSymbol(node, scope.peek()); return node;} // field name
}

NodeFunctionParamArgs FunctionParamArgs () : {NodeFunctionParamArgs result; Node type; Node name;}
{
  {result = new NodeFunctionParamArgs();}

  [ 
    type = Type() 
    name = Vid()  {result.addParameter(type, name);}
    ( 
      "," type = Type() 
      name = Vid() 
      {result.addParameter(type, name);} 
    )* 
  ]

  {return result;}
}

Node Declaration_Definition () : {Node result = null; Node newNode; Node type; Node name;
  NodeStructSignature resultStructSig; NodeFunctionSignature resultFunctionSig; NodeFunctionParamArgs newParams;}
{
  (
    LOOKAHEAD (3)
    <STRUCT> name = Sid() {resultStructSig = new NodeStructSignature(name);scope.push(resultStructSig);}
      [ 
        // [ ] Warum hier Klammer nicht tokenized?
        "{" {result = new NodeStructDefinition(resultStructSig);}
        ( type=Type() name=Vid() {((NodeStructDefinition)result).addElement(type, name);}";")* "}" 
      ] 
      ";" {if(result == null) {result = new NodeStructDeclaration(resultStructSig);}}
    |
    type=Type() name=Vid() {resultFunctionSig = new NodeFunctionSignature(type, name);scope.push(resultFunctionSig);}
    "(" 
    newParams = FunctionParamArgs() {resultFunctionSig.addParameters(newParams);} 
    ")" 
    ( 
      newNode=Block() {result = new NodeFunctionDefinition(resultFunctionSig, newNode);}  
      | 
      ";" {result = new NodeFunctionDeclaration(resultFunctionSig);} 
    )
  )
  {scope.pop(); return result;}
}

Node Block() : {NodeBlock result; Node newNode; Token token;}
{
  // [ ] Warum hier Klammer tokenized?
  token = "{" {result = new NodeBlock(token); scope.push(result);} 
  ( 
    newNode=Statement() {result.addStatement(newNode);}
  )* 
  "}"
  {scope.pop(); return result;}
}

Node Statement () : {Node result = null; NodeStatementIf resultIf;
  NodeStatementWhile resultWhile; NodeStatementFor resultFor;
  NodeStatementReturn resultReturn; Node newNode = null; Token token;}
{
  (
    newNode = Expression() 
    ";" {result=new NodeStatementExpression(newNode);}
    |
    token = <IF> 
    "(" 
    newNode = Expression() {resultIf=new NodeStatementIf(newNode,token);}
    ")" 
    newNode=Statement() {resultIf.setIf(newNode);}
    [ 
      LOOKAHEAD(2) 
      <ELSE> 
      newNode = Statement() {resultIf.setElse(newNode);}
    ] {result=resultIf;}
    |
    token = <WHILE> 
    "(" 
    newNode = Expression() {resultWhile=new NodeStatementWhile(newNode, token);}
    ")" 
    newNode = Statement() {resultWhile.setLoopBody(newNode);result=resultWhile;}
    |
    token = <FOR> {resultFor=new NodeStatementFor(token);} 
    "(" 
    [ 
      newNode=Expression() {resultFor.setInitializer(newNode);}
    ] 
    ";" newNode=Expression() {resultFor.setCondition(newNode);}
    ";" 
    [ 
      newNode=Expression() {resultFor.setIterator(newNode);}
    ] 
    ")" newNode=Statement()
    {resultFor.setLoopBody(newNode);result=resultFor;}
    |
    token = <RETURN> {resultReturn=new NodeStatementReturn(token);}
    [ 
      newNode=Expression() {resultReturn.setReturnValue(newNode);} 
    ] 
    ";" {result=resultReturn;}
    |
    result = Block() //No need to create a seperate statment block node, everything is already in the block
  )
  {return result;}
}

NodeMemberAccess MemberAccess () : {Node newNode; NodeMemberAccess memberaccess;Token token;}
{
  (
    token = "." newNode = Fid() {memberaccess = new NodeMemberAccessDot(newNode, token);}
    |
    token = "->" newNode = Fid() {memberaccess = new NodeMemberAccessArrow(newNode, token);}
    |
    token = "[" newNode = Expression() "]" {memberaccess = new NodeMemberAccessArray(newNode, token);}
  )
  [
    newNode = MemberAccess() {memberaccess.setAccessingNode(newNode);} 
  ]
  {return memberaccess;}
}

Node Type () : {Node result; Node newNode;Token token;}
{
	(
		token = <INT> {result = new NodeTypeInt(token);} 
    | 
    token = <BOOLEAN> {result = new NodeTypeBool(token);}
    | 
    token = <VOID> {result = new NodeTypeVoid(token);}
		|
		token = <STRUCT> newNode = Sid() {result = new NodeTypeStruct(newNode);}
	)
	( 
		"*" {result = new NodeTypePointer(result);}
    | 
    "["
    "]" {result = new NodeTypeArray(result);}
	)*
  {return result;}
}

NodeFunctionCallArgs FunctionCallArgs () : {NodeFunctionCallArgs result; Node newNode;}
{
  {result = new NodeFunctionCallArgs();}
  [ 
    newNode = Expression() {result.addArg(newNode);}
    (
      "," newNode = Expression() {result.addArg(newNode);}
    )* 
  ]
  {return result;}
}

Node Expression () : {Node result; Node array_alloc_size; Token token;
  Node type; Node name; Node newNode; NodeExpressionAssign resultAssign;}
{	
  token=<ALLOC> 
  "(" result=Type() 
  ")" {return new NodeExpressionAlloc(result,token);}
  |
  token=<ALLOC_ARR> 
  "(" result=Type() 
  "," array_alloc_size=Expression() 
  ")" {return new NodeExpressionAllocArray(result,token,array_alloc_size);}
  |
  result=OpRang_Assign() {return result;}
  |
  type=Type() 
  name=Vid() {result = new NodeExpressionVariableDefinition(type,name);}
  [ 
    LOOKAHEAD(2) {resultAssign= new NodeExpressionAssign(result);} 
    token = "=" 
    newNode=OpRang_Conditional() {resultAssign.setOp("=",token);resultAssign.setSecondary(newNode);result=resultAssign;}
  ]
  {return result;}
}

Node OpRang_Assign () : {Node result; NodeExpressionBinary operator = null; NodeExpressionAssign resultAssign; Token opToken;}
{
  result=OpRang_Conditional()
  [ 
    LOOKAHEAD(2)
    {resultAssign= new NodeExpressionAssign(result);}
    (
      opToken="="  | 
      opToken="+=" {operator = new NodeExpressionSum(result);      operator.setOp("+", opToken);}|    //Untangle "a += b;" to "a = a + b"
      opToken="-=" {operator = new NodeExpressionSum(result);      operator.setOp("-", opToken);}| 
      opToken="*=" {operator = new NodeExpressionFactor(result);   operator.setOp("*", opToken);}| 
      opToken="/=" {operator = new NodeExpressionFactor(result);   operator.setOp("/", opToken);}| 
      opToken="%=" {operator = new NodeExpressionFactor(result);   operator.setOp("%", opToken);}| 
      opToken="<<="{operator = new NodeExpressionBitShift(result); operator.setOp("<<", opToken);}| 
      opToken=">>="{operator = new NodeExpressionBitShift(result); operator.setOp(">>", opToken);}| 
      opToken="&=" {operator = new NodeExpressionBitAnd(result);   operator.setOp("&", opToken);}| 
      opToken="^=" {operator = new NodeExpressionBitXor(result);   operator.setOp("^", opToken);}| 
      opToken="|=" {operator = new NodeExpressionBitOr(result);    operator.setOp("|", opToken);}
    ) 
    result=OpRang_Conditional() {resultAssign.setOp("=", opToken);
                                if(operator == null){resultAssign.setSecondary(result);} 
                                else{operator.setSecondary(result); resultAssign.setSecondary(operator);}
                                result=resultAssign;}
  ]
  {return result;}
}

Node OpRang_Conditional () : {Node result; NodeStatementIf resultIf; Token token;}
{
  //Using the normal If Node since this here is just a shorthand for the normal if then else construct
  result = OpRang_LogicalOr() 
  [ 
    LOOKAHEAD(2)  
    ( 
      token = "?" {resultIf = new NodeStatementIf(result, token);} 
      result=Expression() {resultIf.setIf(result);}
      ":" result=Expression() {resultIf.setElse(result); result = resultIf;}
    ) 
  ]
  {return result;}
}

Node OpRang_LogicalOr () : {Node result; NodeExpressionBinary resultBin;Token opToken;}
{
  result=OpRang_LogicalAnd() 
  [ 
    {resultBin = new NodeExpressionLogicalOr(result);} 
    ( // [?] Warum geklammert?
      opToken = "||" 
    ) 
    result=OpRang_LogicalOr()  {resultBin.setOp("||",opToken); resultBin.setSecondary(result);result=resultBin;}
  ]
  {return result;}
}

Node OpRang_LogicalAnd () : {Node result;NodeExpressionBinary resultBin;Token opToken;}
{
  result=OpRang_BitOr() 
  [ 
    {resultBin = new NodeExpressionLogicalAnd(result);} 
    ( // [?] Warum geklammert?
      opToken="&&" 
    ) 
    result=OpRang_LogicalAnd()  {resultBin.setOp("&&",opToken);resultBin.setSecondary(result);result=resultBin;}
  ]
  {return result;}
}

Node OpRang_BitOr () : {Node result;NodeExpressionBinary resultBin;Token opToken;}
{
  result=OpRang_BitXor() 
  [ 
    {resultBin = new NodeExpressionBitOr(result);} 
    ( 
      opToken="|" 
    ) 
    result=OpRang_BitOr()  {resultBin.setOp("|",opToken);resultBin.setSecondary(result);result=resultBin;}
  ]
  {return result;}
}

Node OpRang_BitXor () : {Node result;NodeExpressionBinary resultBin;Token opToken;}
{
  result=OpRang_BitAnd() 
  [ 
    {resultBin = new NodeExpressionBitXor(result);} 
    ( 
      opToken="^" 
    ) 
    result=OpRang_BitXor()  {resultBin.setOp("^",opToken);resultBin.setSecondary(result);result=resultBin;}
  ]
  {return result;}
}

Node OpRang_BitAnd () : {Node result;NodeExpressionBinary resultBin;Token opToken;}
{
  result=OpRang_Equality() 
  [
    {resultBin = new NodeExpressionBitAnd(result);}
    ( 
      opToken="&" 
    ) 
    result=OpRang_BitAnd() {resultBin.setOp("&",opToken);resultBin.setSecondary(result);result=resultBin;}
  ]
  {return result;}
}

Node OpRang_Equality () : {Node result;NodeExpressionBinary resultBin;Token opToken;}
{
  result=OpRang_Compare() 
  [
    {resultBin = new NodeExpressionEquality(result);} 
    ( 
      opToken="==" {resultBin.setOp("==",opToken);}
      | 
      opToken="!=" {resultBin.setOp("!=",opToken);}
    ) 
    result=OpRang_Equality() {resultBin.setSecondary(result);result=resultBin;}
  ]
  {return result;}
}

Node OpRang_Compare () : {Node result;NodeExpressionBinary resultBin;Token opToken;}
{
  result=OpRang_BitShift() 
  [
    {resultBin = new NodeExpressionCompare(result);} 
    ( 
      opToken="<" {resultBin.setOp("<",opToken);}
      | 
      opToken=">" {resultBin.setOp(">",opToken);}
      | 
      opToken=">=" {resultBin.setOp(">=",opToken);}
      | 
      opToken="<=" {resultBin.setOp("<=",opToken);}
    ) 
    result=OpRang_Compare() {resultBin.setSecondary(result);result=resultBin;}
  ]
  {return result;}
}

Node OpRang_BitShift () : {Node result;NodeExpressionBinary resultBin;Token opToken;}
{
  result=OpRang_Sum() [ {resultBin = new NodeExpressionBitShift(result);} 
        ( opToken="<<" {resultBin.setOp("<<",opToken);}| 
          opToken=">>" {resultBin.setOp(">>",opToken);}) 
        result=OpRang_BitShift() {resultBin.setSecondary(result);result=resultBin;}]
  {return result;}
}

Node OpRang_Sum () : {Node result;NodeExpressionBinary resultBin;Token opToken;}
{
  result=OpRang_Factor() 
  [ 
    {resultBin = new NodeExpressionSum(result);} 
    ( 
      opToken="+" {resultBin.setOp("+",opToken);}
      | 
      opToken="-" {resultBin.setOp("-",opToken);}
    ) 
    result=OpRang_Sum() {resultBin.setSecondary(result);result=resultBin;}
  ]
  {return result;}
}

Node OpRang_Factor () : {Node result; Node newNode;NodeExpressionBinary resultBin;Token opToken;}
{
  result=OpRang_Unary() 
  [ 
    {resultBin = new NodeExpressionFactor(result);} 
    (
      opToken="*" {resultBin.setOp("*",opToken);} 
      |
      opToken="/" {resultBin.setOp("/",opToken);} 
      | 
      opToken="%" {resultBin.setOp("%",opToken);} 
    ) 
    newNode=OpRang_Factor() {resultBin.setSecondary(newNode);result=resultBin;}
  ] 
  {return result;}
}

Node OpRang_Unary () : {NodeExpressionUnary unaryOp = null; Node result; 
  NodeMemberAccess memberaccess = null; NodeFunctionCallArgs functionArgs; Token token;}
{
  //gather information for this node...
  [
    token="*" {unaryOp=new NodeExpressionUnaryDereference(token);} 
    | 
    token="-" {unaryOp=new NodeExpressionUnaryMinus(token);} 
    | 
    token="~" {unaryOp=new NodeExpressionUnaryBitwiseNegation(token);} 
    |
    token="!" {unaryOp=new NodeExpressionUnaryNegation(token);}
  ]
  (
    result=Vid() 
    [ 
      "(" 
      functionArgs=FunctionCallArgs() 
      ")" {result = new NodeExpressionFunctionCall(result, functionArgs);} 
      | 
      token="--" { result = new NodeExpressionDecrement(result, token);}
      | 
      token="++" { result = new NodeExpressionIncrement(result, token);}
    ]
    |
    token=<NUM>  {result= new NodeExpressionConstNum(token);}	
    | 
    token=<TRUE> {result= new NodeExpressionConstTrue(token);} 
    | 
    token=<FALSE>{result= new NodeExpressionConstFalse(token);} 
    | 
    token=<NULL> {result= new NodeExpressionConstNull(token);}
    |
    token="(" 
    result=OpRang_Conditional() {result = new NodeExpressionBrackets(result, token);} 
    ")"
  )
  [
    /*
     * If there is a constant or function before that, then the type checker will complain here,
     * unless the returned item is a stack or something :)
     */
    memberaccess=MemberAccess()
  ]
  //...and assemble it
  {
    if(memberaccess != null)
    { memberaccess.setAccessingNode(result); result=memberaccess; }
    if(unaryOp != null)
    { unaryOp.setInternNode(result); result=unaryOp; }
    return result;
  }
}