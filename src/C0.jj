options
{
  DEBUG_PARSER = true;
  DEBUG_TOKEN_MANAGER = true;
}

PARSER_BEGIN(C0)
public class C0 {
	public static void main(String args[]) throws ParseException {
		new C0(System.in).Program();
	}
}
PARSER_END(C0)

// Whitespace separates tokens, but is otherwise ignored. Other control (non-printing) characters in the input constitute an error.
SKIP : { " " | "\t" }

// Keywords
TOKEN : {
	< INT:        	"int" >
	| < BOOLEAN:    "bool" >
	| < STRING:     "string" >
	| < CHAR:       "char" >
	| < VOID:       "void" >
	| < STRUCT:     "struct" >
	| < IF:         "if" >
	| < ELSE:       "else" >
	| < WHILE:      "while" >
	| < FOR:        "for" >
	| < RETURN:     "return" >
	| < TRUE:       "true" >
	| < FALSE:      "false" >
	| < NULL:       "NULL" >
	| < ALLOC:      "alloc" >
  | < ALLOC_ARR:  "alloc_array" >
}

// Separators
TOKEN : {
	< LPAREN: "(" >
	| < RPAREN: ")" >
	| < LBRACE: "{" >
	| < RBRACE: "}" >
	| < LBRACKET: "[" >
  | < RBRACKET: "]" >
  | < LWICKET: "<" >
  | < RWICKET: ">" >
  | < COLON: ":" >
  | < SEMICOLON: ";" >
	| < COMMA: "," >
	| < DOT: "." >
	| < EOL: "\n" | "\r" | "\r\n" | "\f" >
}

// Operators
TOKEN : {
	< STAR: "*" >
  | < PLUSPLUS: "++">
  | < MINUSMINUS: "--">
  | < EQUALS: "=">
  | < ASSIGN: "->">
  | < QUESTION: "?">
  | < ASNOP: "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | "&=" | "^=" | "|=" >  
  | < UNOP: "!" | "~" | "-" | "*" >
}

// Lexical Tokens
TOKEN : {
	< ID: <LETTER> ( <ALPHANUM> )* >
	|	< #LETTER: ["$","A"-"Z","a"-"z","_"] >
	|	< #ALPHANUM: ["$","A"-"Z","a"-"z","0"-"9","_"] >
	|	< NUM: <DECNUM> | <HEXNUM> >
	|	< DECNUM: "0" | ["1"-"9"](["1"-"9"])* >
	|	< HEXNUM: "0" ("x" | "X") (["0"-"9","a"-"f","A"-"F"])+ >
	// | < STRLIT: "\"" (<SCHAR>)* "\"" >
	// |   < CHRLIT: "'" <CCHAR> "'" >
	// |   < LIBLIT: "<" (<LCHAR>)* ">" >
  // |   < SCHAR: <NCHAR> | <ESC> >
	// |   < CCHAR: <NCHAR> | <ESC> | "\"" | "\0" >
	// |   < NCHAR: (~["\""])+ >
	// |   < LCHAR: (~[">"])+ >
	// |   < ESC: "\n" | "\t" | "\\v" | "\b" | "\r" | "\f" | "\\a" | "\\" | "\'" | "\"" >
	// |   < SEP: "(" | ")" | "[" | "]" | "{" | "}" | "," | ";" >
	 // |	< BINOP: "." | "->" | "*" | "/" | "%" | "+" | "-" | "<<" | ">>" | "<" | "<=" | ">=" | ">" | "==" | "!=" | "&" | "^" | "|" | "&&" | "||" | "?" | ":" >
	// |	< POSTOP: "--" | "++" >
}

void Program() : {}
{
	( Declaration() | Definition() )* <EOF>
}

void Sid() : {}
{
  <ID>  // struct name
}

void Vid() : {}
{
  <ID>  // variable and function name
}

void Fid() : {}
{
  <ID>  // field name
}

void Declaration_Definition() : {}
{
  LOOKAHEAD (3) // otherwise posssible conflict with a definition of a function with return type struct
	<STRUCT> Sid() [ <LBRACE> ( Type() Vid() <SEMICOLON> )* <RBRACE> ] <SEMICOLON>
	|
  Type() Vid() <LPAREN> [ Type() Vid() ( <COMMA> Type() Vid() )* ] <RPAREN> ( <LBRACE> ( Statement() )* <RBRACE> | <SEMICOLON> )
}

void Statement() : {}
{
	Simple() <SEMICOLON>
	|
  <IF> <LPAREN> Expression() <RPAREN> Statement() [ <ELSE> Statement() ]
	|
  <WHILE> <LPAREN> Expression() <RPAREN> Statement()
	|
  <FOR> <LPAREN> [ Simple() ] <SEMICOLON> Expression() <SEMICOLON> [ Simple() ] <RPAREN> Statement()
	|
  <RETURN> [ Expression() ]
	|
  <LBRACE> ( Statement() )* <RBRACE>
}

void Simple() : {}
{
	MemberAccess() <ASNOP> Expression()
	|	MemberAccess() <PLUSPLUS>
	|	MemberAccess() <MINUSMINUS>
	|	Expression()
	|	Type() <ID> [ <EQUALS> Expression() ]
}

void MemberAccess() : {}
{
	<ID>
	|	MemberAccess() <DOT> <ID>
	|	MemberAccess() <ASSIGN> <ID>
	|	<STAR> MemberAccess()
	|	MemberAccess() <LBRACE> Expression() <RBRACE>
	|	<LPAREN> MemberAccess() <RPAREN>
}

void Type() : {} 
{
	<INT>
	|	<BOOLEAN>
	|	<STRING>
	|	<CHAR>
	|	<VOID>
	|	Type() <STAR>
	|	Type() <LBRACKET> <RBRACKET>
	|	<STRUCT> <ID>
	// |	<##aid>
}

void Expression() : {}
{
	<LBRACE> Expression() <RBRACE>
	|	<NUM>
	// |	<##strlit>
	// |	<##chrlit>
	|	<TRUE>
	|	<FALSE>
	|	<NULL>
	|	<ID>
	|	Expression() <BINOP> Expression()
	| <UNOP> Expression() 
	| Expression() <QUESTION> Expression() <COLON> Expression()
	| <ID> <LPAREN> [ Expression() ( <COMMA> Expression() )* ] <RPAREN>
	| Expression() <DOT> <ID>
	| Expression() <ASSIGN> <ID>
	| Expression() <LBRACKET> Expression() <RBRACKET>
	| <ALLOC> <LPAREN> Type() <RPAREN>
	| <ALLOC_ARR> <LPAREN> Type() <SEMICOLON> Expression() <RPAREN>

}

///////////////////////////////////////////
/*
	void Method() : {} 
	{
		MethodType() <ID> "(" Params() ")" "{" ExecutionContext() "}"
	}

	void MethodType() : {}
	{
		<VOID> | <INT> | <BOOLEAN> | <STRING> | <CHAR>
	}

	void VariableType() : {}
	{
		(<INT> | <BOOLEAN> | <STRING> | <CHAR>) ["[" "]"]
	}

	void Params() : {}
	{
		[ParamsType() <ID> ("," ParamsType() <ID>)*]
	}

	void ParamsType() : {}
	{
		(<INT> | <CHAR> | <STRING> | <BOOLEAN>) ("[" "]")*
	}

	void ExecutionContext() : {}
	{
		(<ID>)*
	}
*/