/**
 * C0-- Parser
 * HS-Fulda - Compiler Constructions
 *
 * @author    Konstantin Ruppel
 * @autor     Juergen Goebel
 * @autor     Sebastian Herr
 * 
 * @date      2017/06/03
 */

PARSER_BEGIN(C0)
public class C0 {
	static boolean x = true;
	public static void main(String args[]) {
		C0 parser;
		try {
			if (args.length > 0) {
				parser = new C0 (new java.io.FileInputStream(new java.io.File(args[0])));
			} else {
				parser = new C0 (System.in);
			}
			parser.Program();
			System.out.println ("[  OK  ]");
		} catch (Exception ex) {
			System.out.println ("[ FAIL ]" + ((args.length > 1) ? ex.getMessage() + "\n\n" : ""));
		}
	}
}
PARSER_END(C0)

SKIP : 
{ 
  " " | "\t" | "\f" | "\n" | "\r" | "\r\n"
  |
  "/*" : IN_ML_COMMENT
  |
  < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >
}

<IN_ML_COMMENT> SKIP :
{
  <~[]>
  |
  "*/" : DEFAULT
}

// Keywords
TOKEN : {
	< INT:        	"int" >
	| < BOOLEAN:    "bool" >
	| < CHAR:       "char" >
	| < VOID:       "void" >
	| < STRUCT:     "struct" >
	| < IF:         "if" >
	| < ELSE:       "else" >
	| < WHILE:      "while" >
	| < FOR:        "for" >
	| < RETURN:     "return" >
	| < TRUE:       "true" >
	| < FALSE:      "false" >
	| < NULL:       "NULL" >
	| < ALLOC:      "alloc" >
  | < ALLOC_ARR:  "alloc_array" >
}

TOKEN : {
	< ID: <LETTER> ( <ALPHANUM> )* >
	|	< #LETTER: ["$","A"-"Z","a"-"z","_"] >
	|	< #ALPHANUM: ["$","A"-"Z","a"-"z","0"-"9","_"] >
	|	< NUM: <DECNUM> | <HEXNUM> >
	|	< DECNUM: "0" | ["1"-"9"](["1"-"9"])* >
	|	< HEXNUM: "0" ("x" | "X") (["0"-"9","a"-"f","A"-"F"])+ >
}

Node Program () : {}
{
  ( 
    Declaration_Definition()
  )* 
  <EOF>
}

Node Sid () : {}
{
  <ID>  // struct name
}

Node Vid () : {}
{
  <ID>  // variable and function name
}

Node Fid () : {}
{
  <ID>  // field name
}

Node Declaration_Definition () : {}
{
  LOOKAHEAD (3)
	<STRUCT> Sid() [ "{" ( Type() Vid() ";" )* "}" ] ";"
	|
  Type() Vid() "(" [ Type() Vid() ( "," Type() Vid() )* ] ")" ( "{" ( Statement() )* "}" | ";" )
}

Node Statement () : {}
{
  Expression() ";"
  |
	<IF> "(" Expression() ")" Statement() [ LOOKAHEAD(2) <ELSE> Statement() ]
	|
	<WHILE> "(" Expression() ")" Statement()
	|
	<FOR> "(" [ Expression() ] ";" Expression() ";" [ Expression() ] ")" Statement()
	|
	<RETURN> [ Expression() ] ";"
	|
	"{" ( Statement() )* "}"
}

Node MemberAccess () : {Node result; Node newNode; Node memberaccess;}
{
  (
    "." newNode=Fid() {result= new NodeMemberAccessDot(newNode);}
    |
    "->" newNode=Fid()
    |
    "[" newNode=Expression() "]"
  )
  [
    memberaccess=MemberAccess() {memberaccess.setAccessingNode(result); result = memberaccess;} 
  ]
  {return result;}
}

Node Type () : {Node result; Node newNode;}
{
	(
		<INT> {result= new NodeTypeInt();} | <BOOLEAN> {result= new NodeTypeBool();}| <VOID>{result= new NodeTypeVoid();}
		|
		<STRUCT> newNode=Sid() {result = new NodeTypeStruct(newNode);}
	)
	( 
		"*" {result = new NodeTypePointer(result);}| "[" "]"{result = new NodeTypeArray(result);}
	)*
  {return result;}
}

Node FunctionCallArgs () : {Node result; Node newNode;}
{
  {result = new NodeFunctionCallArgs();}
  [ newNode=Expression() {result.addArg(newNode);}("," newNode=Expression() {result.addArg(newNode);})* ]
}

Node Expression () : {Node result; Node array_alloc_size; Node type; Node name; Node newNode;}
{	
  <ALLOC> "(" result=Type() ")" {return new NodeExpressionAlloc(result);}
  |
  <ALLOC_ARR> "(" result=Type() "," array_alloc_size=Expression() ")" 
    {return new NodeExpressionAllocArray(result,array_alloc_size);}
  |
  result=OpRang_Assign() {return result;}
  |
  type=Type() name=Vid() {result = new NodeExpressionVariableDefinition(type,name);}
    [ LOOKAHEAD(2) {result= new NodeExpressionAssign(result); result.setOp("=");} 
      "=" newNode=OpRang_Conditional() {result.setSecondary(newNode);}]
    {return result;}
}

Node OpRang_Assign () : {Node result;}
{
  result=OpRang_Conditional()
  [ 
    LOOKAHEAD(2)
    {result= new NodeExpressionAssign(result);}
    (
      "=" {result.setOp("=");}| 
      "+=" {result.setOp("+=");}| 
      "-=" {result.setOp("-=");}| 
      "*=" {result.setOp("*=");}| 
      "/=" {result.setOp("/=");}| 
      "%=" {result.setOp("%=");}| 
      "<<=" {result.setOp("<<=");}| 
      ">>=" {result.setOp(">>");}| 
      "&=" {result.setOp("&=");}| 
      "^=" {result.setOp("^=");}| 
      "|=" {result.setOp("|=");}
    ) 
    newNode=OpRang_Conditional() {result.setSecondary(newNode);}
  ]
  {return result;}
}

Node OpRang_Conditional () : {Node result; Node newNode;}
{
  result=OpRang_LogicalOr() [ LOOKAHEAD(2) {result = new NodeExpressionConditional(result);} 
        ( "?" newNode=Expression() {result.setSecondary(newNode);} ":" newNode=Expression() {result.setTernary(newNode);} ) ]
  {return result;}
}

Node OpRang_LogicalOr () : {Node result;}
{
  result=OpRang_LogicalAnd() [ {newNode = new NodeExpressionLogicalOr(result);} 
        ( "||" ) newNode=OpRang_LogicalOr()  {result.setSecondary(newNode);}]
  {return result;}
}

Node OpRang_LogicalAnd () : {Node result;}
{
  result=OpRang_BitOr() [ {newNode = new NodeExpressionLogicalAnd(result);} 
        ( "&&" ) newNode=OpRang_LogicalAnd()  {result.setSecondary(newNode);}]
  {return result;}
}

Node OpRang_BitOr () : {Node result;}
{
  result=OpRang_BitXor() [ {newNode = new NodeExpressionBitOr(result);} 
        ( "|" ) newNode=OpRang_BitOr()  {result.setSecondary(newNode);}]
  {return result;}
}

Node OpRang_BitXor () : {Node result;}
{
  result=OpRang_BitAnd() [ {newNode = new NodeExpressionBitXor(result);} 
        ( "^" ) newNode=OpRang_BitXor()  {result.setSecondary(newNode);}]
  {return result;}
}

Node OpRang_BitAnd () : {Node result;}
{
  result=OpRang_Equality() [ {newNode = new NodeExpressionBitAnd(result);} 
        ( "&" ) newNode=OpRang_BitAnd() {result.setSecondary(newNode);} ]
  {return result;}
}

Node OpRang_Equality () : {Node result;}
{
  result=OpRang_Compare() [ {newNode = new NodeExpressionEquality(result);} 
        ( "==" {result.setOp("<");}| 
          "!=" {result.setOp("<");}) newNode=OpRang_Equality() {result.setSecondary(newNode);}]
 {return result;}
}

Node OpRang_Compare () : {Node result;}
{
  result=OpRang_BitShift() [ {newNode = new NodeExpressionCompare(result);} 
        ( "<" {result.setOp("<");}| 
          ">" {result.setOp(">");}| 
          ">=" {result.setOp(">=");}| 
          "<=" {result.setOp("<=");}) newNode=OpRang_Compare() {result.setSecondary(newNode);}]
  {return result;}
}

Node OpRang_BitShift () : {Node result;}
{
  result=OpRang_Sum() [ {newNode = new NodeExpressionBitShift(result);} 
        ("<<" {result.setOp("<<");}| 
         ">>" {result.setOp(">>");}) newNode=OpRang_BitShift() {result.setSecondary(newNode);}]
  {return result;}
}

Node OpRang_Sum () : {Node result;}
{
  result=OpRang_Factor() [ {result = new NodeExpressionSum(result);} 
        ("+" {result.setOp("+");}| 
         "-" {result.setOp("-");}) newNode=OpRang_Sum() {result.setSecondary(newNode);}]
  {return result;}
}

Node OpRang_Factor () : {Node result; Node newNode;}
{
  result=OpRang_Unary() [ {result = new NodeExpressionFactor(result);} 
        ("*" {result.setOp("*");} |
         "/" {result.setOp("/");} | 
         "%" {result.setOp("%");} ) 
         newNode=OpRang_Factor() {result.setSecondary(newNode);}] 
  {return result;}
}

Node OpRang_Unary () : {Node unaryOp; Node result; Node memberaccess; Node functionArgs;}
{
  //gather information for this node...
  [
    "*" {unaryOp=new NodeExpressionUnaryDereference();} | 
    "-" {unaryOp=new NodeExpressionUnaryMinus();} | 
    "~" {unaryOp=new NodeExpressionUnaryBitwiseNegation();} |
    "!" {unaryOp=new NodeExpressionUnaryNegation();}
  ]
  (
    result=Vid() [ "(" functionArgs=FunctionCallArgs() ")" {result = new NodeExpressionFunctionCall(result, functionArgs);} | 
                   "--" { result = new NodeExpressionDecrement(result);}| 
                   "++" { result = new NodeExpressionIncrement(result);}]
    |
      <NUM>  {result= new NodeExpressionConstNum();}	
    | 
      <TRUE> {result= new NodeExpressionConstTrue();} 
    | 
      <FALSE>{result= new NodeExpressionConstFalse();} 
    | 
      <NULL> {result= new NodeExpressionConstNull();}
    |
    "(" result=OpRang_Conditional() ")"
  )
  [
    /*
     * If there is a constant or function before that, then the type checker will complain here,
     * unless the returned item is a stack or something :)
     */
    memberaccess=MemberAccess()
  ]
  //...and assemble it
  {
    if(memberaccess != null)
    { memberaccess.setAccessingNode(result); result=memberaccess; }
    if(unaryOp != null)
    { unaryOp.setInternNode(result); result=unaryOp; }
    return result;
  }
}