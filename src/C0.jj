options
{
	LOOKAHEAD=1001;
	FORCE_LA_CHECK=false;
}

PARSER_BEGIN(C0)
public class C0 {
	public static void main(String args[]) throws ParseException {
		new C0(System.in).Program();
	}
}
PARSER_END(C0)

// Whitespace separates tokens, but is otherwise ignored. Other control (non-printing) characters in the input constitute an error.
SKIP : { " " | "\t" }

// Keywords
TOKEN : {
	< INT:        "int" >
	| < BOOLEAN:    "bool" >
	| < STRING:     "string" >
	| < CHAR:       "char" >
	| < VOID:       "void" >
	| < STRUCT:     "struct" >
	| < TYPEDEF:    "typedef" >
	| < IF:         "if" >
	| < ELSE:       "else" >
	| < WHILE:      "while" >
	| < FOR:        "for" >
	| < CONTINUE:   "continue" >
	| < BREAK:      "break" >
	| < RETURN:     "return" >
	| < ASSERT:     "assert" >
	| < TRUE:       "true" >
	| < FALSE:      "false" >
	| < NULL:       "NULL" >
	| < ALLOC:      "alloc" >
	| < ALLOC_ARR:  "alloc_array" >
}

// Separators
TOKEN : {
		< LPAREN: "(" >
	| < RPAREN: ")" >
	| < LBRACE: "{" >
	| < RBRACE: "}" >
	| < LBRACKET: "[" >
	| < RBRACKET: "]" >
	| < SEMICOLON: ";" >
	| < COMMA: "," >
	| < DOT: "." >
	| < EOL: "\n" | "\r" | "\r\n" >
}

// Operators
TOKEN : {
	< STAR: "*" >
}

// Lexical Tokens
TOKEN : {
	< ID: <LETTER> ( <ALPHANUM> )* >
	|	< #LETTER: ["$","A"-"Z","a"-"z","_"] >
	|	< #ALPHANUM: ["$","A"-"Z","a"-"z","0"-"9","_"] >
	|	< NUM: <DECNUM> | <HEXNUM> >
	|	< DECNUM: "0" | ["1"-"9"](["1"-"9"])* >
	|	< HEXNUM: "0" ("x" | "X") (["0"-"9","a"-"f","A"-"F"])+ >
	// | < STRLIT: "\"" (<SCHAR>)* "\"" >
	// |   < CHRLIT: "'" <CCHAR> "'" >
	// |   < LIBLIT: "<" (<LCHAR>)* ">" >
  // |   < SCHAR: <NCHAR> | <ESC> >
	// |   < CCHAR: <NCHAR> | <ESC> | "\"" | "\0" >
	// |   < NCHAR: (~["\""])+ >
	// |   < LCHAR: (~[">"])+ >
	// |   < ESC: "\n" | "\t" | "\\v" | "\b" | "\r" | "\f" | "\\a" | "\\" | "\'" | "\"" >
	// |   < SEP: "(" | ")" | "[" | "]" | "{" | "}" | "," | ";" >
	 |	< UNOP: "!" | "~" | "-" | "*" >
	 |	< BINOP: "." | "->" | "*" | "/" | "%" | "+" | "-" | "<<" | ">>" | "<" | "<=" | ">=" | ">" | "==" | "!=" | "&" | "^" | "|" | "&&" | "||" | "?" | ":" >
	 |	< ASNOP: "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | "&=" | "^=" | "|=" >
	// |	< POSTOP: "--" | "++" >
}

void Program() : {}
{
	( Declaration() | Definition() )* <EOF>
}

void Declaration() : {}
{
	<STRUCT> <ID> <SEMICOLON>
	|	Type() <ID> "(" [ Type() <ID> ( <COMMA> Type() <ID> )* ] ")" <SEMICOLON>
	|	"#use" "<" <ID> ">" <EOL>
	|	"#use" "\"" <ID> "\"" <EOL>
}

void Definition() : {}
{
	<STRUCT> <ID> "{" ( Type() <ID> )* "}" ";"
	|	Type() <ID> "(" [ Type() <ID> (<COMMA> Type() <ID>)* ] ")" "{" ( Statement() )* "}"
	//| "typedef" Type() <##aid> // C0--
}

void Statement() : {}
{
	Simple() ";"
	|	"if" "(" Expression() ")" Statement() [ "else" Statement() ]
	|	"while" "(" Expression() ")" Statement()
	|	"for" "(" [ Simple() ] ";" Expression() ";" [ Simple() ] ")" Statement()
	|	"return" [ Expression() ]
	|	"{" ( Statement() )* "}"
	|	"assert" "(" Expression() ")" ";"
	|	"error" "(" Expression() ")" ";"
}

void Simple() : {}
{
	MemberAccess() <ASNOP> Expression()
	|	MemberAccess() "++"
	|	MemberAccess() "--"
	|	Expression()
	|	Type() <ID> [ "=" Expression() ]
}

void MemberAccess() : {}
{
	<ID>
	|	MemberAccess() "." <ID>
	|	MemberAccess() "->" <ID>
	|	"*" MemberAccess()
	|	MemberAccess() [ Expression() ]
	|	"(" MemberAccess() ")"
}

void Type() : {} 
{
	<INT>
	|	<BOOLEAN>
	|	<STRING>
	|	<CHAR>
	|	<VOID>
	|	Type() <STAR>
	|	Type() <LBRACKET> <RBRACKET>
	|	<STRUCT> <ID>
	// |	<##aid>
}

void Expression() : {}
{
	<LBRACE> Expression() <RBRACE>
	|	<NUM>
	// |	<##strlit>
	// |	<##chrlit>
	|	<TRUE>
	|	<FALSE>
	|	<NULL>
	|	<ID>
	|	Expression() <BINOP> Expression()
	| <UNOP> Expression() 
	| Expression() "?" Expression() ":" Expression() 
	| <ID> "(" [ Expression() ( "," Expression() )* ] ")" 
	| Expression() "." <ID> 
	| Expression() "->" <ID> 
	| Expression() "[" Expression() "]"
	| "alloc" "(" Type() ")" 
	| "alloc_array" "(" Type() "," Expression() ")"

}

///////////////////////////////////////////
/*
	void Method() : {} 
	{
		MethodType() <ID> "(" Params() ")" "{" ExecutionContext() "}"
	}

	void MethodType() : {}
	{
		<VOID> | <INT> | <BOOLEAN> | <STRING> | <CHAR>
	}

	void VariableType() : {}
	{
		(<INT> | <BOOLEAN> | <STRING> | <CHAR>) ["[" "]"]
	}

	void Params() : {}
	{
		[ParamsType() <ID> ("," ParamsType() <ID>)*]
	}

	void ParamsType() : {}
	{
		(<INT> | <CHAR> | <STRING> | <BOOLEAN>) ("[" "]")*
	}

	void ExecutionContext() : {}
	{
		(<ID>)*
	}
*/