PARSER_BEGIN(C0)
public class C0 {
	public static void main(String args[]) {
		C0 parser;
		try {
			if (args.length > 0) {
				parser = new C0 (new java.io.FileInputStream(new java.io.File(args[0])));
			} else {
				parser = new C0 (System.in);
			}
			parser.Program();
			System.out.println ("[  OK  ]");
		} catch (Exception ex) {
			System.out.println ("[ FAIL ]\n\n" + ex.getMessage());
		}
	}
}
PARSER_END(C0)

SKIP : { " " | "\t" | "\n" | "\r" | "\r\n" | "/*" : IN_COMMENT }
<IN_COMMENT> MORE : {	<~[]> | "*/" : DEFAULT }

// Keywords
TOKEN : {
	< INT:        	"int" >
	| < BOOLEAN:    "bool" >
	| < STRING:     "string" >
	| < CHAR:       "char" >
	| < VOID:       "void" >
	| < STRUCT:     "struct" >
	| < TYPEDEF:    "typedef" >
	| < IF:         "if" >
	| < ELSE:       "else" >
	| < WHILE:      "while" >
	| < FOR:        "for" >
	| < CONTINUE:   "continue" >
	| < BREAK:      "break" >
	| < RETURN:     "return" >
	| < ASSERT:     "assert" >
	| < TRUE:       "true" >
	| < FALSE:      "false" >
	| < NULL:       "NULL" >
	| < ALLOC:      "alloc" >
  | < ALLOC_ARR:  "alloc_array" >
  | < USE:  			"#use" >
  | < ERROR:			"error" >
}

// Separators
TOKEN : {
	< LPAREN: "(" >
	| < RPAREN: ")" >
	| < LBRACE: "{" >
	| < RBRACE: "}" >
	| < LBRACKET: "[" >
  | < RBRACKET: "]" >
  | < LWICKET: "<" >
  | < RWICKET: ">" >
  | < QUOTE: "\"" >
  | < COLON: ":" >
  | < SEMICOLON: ";" >
	| < COMMA: "," >
}

// Operators
TOKEN : {
	< STAR: "*" >
  | < PLUSPLUS: "++">
  | < MINUSMINUS: "--">
  | < EQUALS: "=">
  | < ASSIGN: "->">
  | < QUESTION: "?">
	| < DOT: "." >
}

// Lexical Tokens
TOKEN : {
	< ID: <LETTER> ( <ALPHANUM> )* >
	|	< #LETTER: ["$","A"-"Z","a"-"z","_"] >
	|	< #ALPHANUM: ["$","A"-"Z","a"-"z","0"-"9","_"] >
	|	< NUM: <DECNUM> | <HEXNUM> >
	|	< DECNUM: "0" | ["1"-"9"](["1"-"9"])* >
	|	< HEXNUM: "0" ("x" | "X") (["0"-"9","a"-"f","A"-"F"])+ >
	|	< UNOP: "!" | "~" | "-" | "*" >
	|	< BINOP: "." | "->" | "*" | "/" | "%" | "+" | "-" | "<<" | ">>" | "<" | "<=" | ">=" | ">" | "==" | "!=" | "&" | "^" | "|" | "&&" | "||" | "?" | ":" >
	|	< ASNOP: "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | "&=" | "^=" | "|=" >
	|	< POSTOP: "--" | "++" >
}

void Program () : {}
{
	( Import () )*
	( LOOKAHEAD(7) Declaration () | Definition () )*
}

void Import () : {}
{
	LOOKAHEAD(2)
		// use < name > \n
		<USE> <LWICKET> <ID> <RWICKET>
		// use " name " \n
	| <USE> <QUOTE> <ID> <QUOTE>
}

void Declaration () : {}
{
	LOOKAHEAD(3)
		// struct name ;
		<STRUCT> <ID> <SEMICOLON>
		// int name ( int name1, int name2 ) ;
	|	Type () <ID> <LPAREN> [ Type () <ID> ( <COMMA> Type () <ID> )* ] <RPAREN> <SEMICOLON>
}

void Definition () : {}
{
	// struct name { int name1 ; int name2 } ;
	LOOKAHEAD(3) <STRUCT> <ID> <LBRACE> ( Type () <ID> <SEMICOLON> )* <RBRACE> <SEMICOLON>
	// int name ( int name1 , int name2 ) { STATEMENT* }
	|	Type () <ID> <LPAREN> [ Type () <ID> ( <COMMA> Type () <ID> )* ] <RPAREN> <LBRACE> ( Statement () )* <RBRACE>
}

void Statement () : {}
{
	// ;
		<SEMICOLON>
	// name ++ ;  													// { STATEMENT* }
	|	( LOOKAHEAD(2) Simple () <SEMICOLON> |	<LBRACE> ( Statement () )* <RBRACE> )
	// if ( EXPRESSION ) STATEMENT else STATEMENT
	|	<IF> <LPAREN> Expression () <RPAREN> Statement () [ LOOKAHEAD(2) <ELSE> Statement () ]
	// while ( EXPRESSION ) STATEMENT
	|	<WHILE> <LPAREN> Expression () <RPAREN> Statement ()
	// for ( SIMPLE ; EXPRESSION ; SIMPLE ) STATEMENT
	|	<FOR> <LPAREN> [ Simple () ] <SEMICOLON> Expression () <SEMICOLON> [ Simple () ] <RPAREN> Statement ()
	// return EXPRESSION ;
	|	<RETURN> [ Expression () ] <SEMICOLON>
	// assert ( EXPRESSION ) ;
	|	<ASSERT> <LPAREN> Expression () <RPAREN> <SEMICOLON>
	// error ( EXPRESSION ) ;
	|	<ERROR> <LPAREN> Expression () <RPAREN> <SEMICOLON>
}

void Simple () : {}
{
	LOOKAHEAD(4)
	MemberAccess () <ASNOP> Expression ()
	|	LOOKAHEAD(MemberAccess () <PLUSPLUS>) MemberAccess () <PLUSPLUS>
	| LOOKAHEAD(MemberAccess () <MINUSMINUS>)	MemberAccess () <MINUSMINUS>
	|	Expression ()
	|	Type () <ID> [ <EQUALS> Expression () ]
}

void MemberAccess () : {}
{
		<ID>
	|	<STAR> MemberAccess ()
	|	<LPAREN> MemberAccess () <RPAREN>
	// |	MemberAccess() <DOT> <ID>
	// |	MemberAccess() <ASSIGN> <ID>
	// |	MemberAccess() [ Expression() ]
}


void Type() : {}
{
		<INT>
	|	<BOOLEAN>
	|	<STRING>
	|	<CHAR>
	|	<VOID>
	|	<STRUCT> <ID>
	// |	Type () <STAR>
	// |	Type () <LBRACKET> <RBRACKET>
}

void Expression() : {}
{
		<LBRACE> Expression () <RBRACE>
	|	<NUM>
	|	<TRUE>
	|	<FALSE>
	|	<NULL>
	|	LOOKAHEAD(2) <ID>
	// name ( EXPRESSION , EXPRESSION )
	| <ID> <LPAREN> [ Expression () ( <COMMA> Expression () )* ] <RPAREN>
	// - EXPRESSION
	| <UNOP> Expression ()
	// alloc ( int )
	| <ALLOC> <LPAREN> Type () <RPAREN>
	// alloc_arr ( int , EXPRESSION )
	| <ALLOC_ARR> <LPAREN> Type () <COMMA> Expression () <RPAREN>

	// |	<##strlit>
	// |	<##chrlit>
	// |	Expression() <BINOP> Expression()
	// | Expression() <QUESTION> Expression() <COLON> Expression()
	// | Expression() <DOT> <ID>
	// | Expression() <ASSIGN> <ID>
	// | Expression() <LBRACKET> Expression() <RBRACKET>
}