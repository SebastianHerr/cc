options
{
  DEBUG_PARSER = true;
  DEBUG_TOKEN_MANAGER = true;
}

PARSER_BEGIN(C0)
public class C0 {
	static boolean x = true;
	public static void main(String args[]) {
		C0 parser;
		try {
			if (args.length > 0) {
				parser = new C0 (new java.io.FileInputStream(new java.io.File(args[0])));
			} else {
				parser = new C0 (System.in);
			}
			parser.Program();
			System.out.println ("[  OK  ]");
		} catch (Exception ex) {
			System.out.println ("[ FAIL ]\n\n" + ex.getMessage());
		}
	}
}
PARSER_END(C0)

SKIP : { " " | "\t" | "\n" | "\r" | "\r\n" | "/*" : IN_COMMENT }
<IN_COMMENT> MORE : {	<~[]> | "*/" : DEFAULT }

// Keywords
TOKEN : {
	< INT:        	"int" >
	| < BOOLEAN:    "bool" >
	| < CHAR:       "char" >
	| < VOID:       "void" >
	| < STRUCT:     "struct" >
	| < IF:         "if" >
	| < ELSE:       "else" >
	| < WHILE:      "while" >
	| < FOR:        "for" >
	| < RETURN:     "return" >
	| < TRUE:       "true" >
	| < FALSE:      "false" >
	| < NULL:       "NULL" >
	| < ALLOC:      "alloc" >
  | < ALLOC_ARR:  "alloc_array" >
}

// Lexical Tokens
TOKEN : {
	< ID: <LETTER> ( <ALPHANUM> )* >
	|	< #LETTER: ["$","A"-"Z","a"-"z","_"] >
	|	< #ALPHANUM: ["$","A"-"Z","a"-"z","0"-"9","_"] >
	|	< NUM: <DECNUM> | <HEXNUM> >
	|	< DECNUM: "0" | ["1"-"9"](["1"-"9"])* >
	|	< HEXNUM: "0" ("x" | "X") (["0"-"9","a"-"f","A"-"F"])+ >
	| < EOL: "\n" | "\r" | "\r\n" | "\f" >
	| < UNOP: "!" | "~" >
}

void Program () : {}
{
	Statement()
	// ( Import () )*
	// ( LOOKAHEAD(Declaration()) Declaration () )*
	// ( LOOKAHEAD(Definition()) Definition () )*
}

void Sid () : {}
{
  <ID>  // struct name
}

void Vid () : {}
{
  <ID>  // variable and function name
}

void Fid () : {}
{
  <ID>  // field name
}

void Declaration_Definition() : {}
{
  LOOKAHEAD (3) // otherwise posssible conflict with a definition of a function with return type struct
	<STRUCT> Sid() [ "{" ( Type() Vid() ";" )* "}" ] ";"
	|
  Type() Vid() "(" [ Type() Vid() ( "," Type() Vid() )* ] ")" ( "{" ( Statement() )* "}" | ";" )
}

void Statement () : {}
{
	<IF> "(" Expression() ")" Statement() [ LOOKAHEAD(2) <ELSE> Statement() ]
	|
	<WHILE> "(" Expression() ")" Statement()
	|
	<FOR> "(" [ Simple() ] ";" Expression() ";" [ Simple() ] ")" Statement()
	|
	<RETURN> [ Expression() ] ";"
	|
	"{" ( Statement() )* "}"
	|
	Simple()
}

void Simple () : {}
{
	Expression()
  |
	// LOOKAHEAD(3) MemberAccess () <ASNOP> Expression ()
	// |
	// LOOKAHEAD(3) MemberAccess () <POSTOP>
	// |
	Type() Vid() [ "=" Expression() ]
}

// void MemberAccess () : {}
// {
// 	(
// 		<ID>
// 		|	
// 		<STAR> MemberAccess ()
// 		|	
// 		<LPAREN> MemberAccess () <RPAREN>
// 	)
// 	[ LOOKAHEAD(2) LeftRecursionMemberAccess () ]
// }

// void LeftRecursionMemberAccess () : {}
// {
// 	<DOT> <ID> [ LOOKAHEAD(3) MemberAccess () ]
// 	|	
// 	<POINTERACCESS> <ID> [ LOOKAHEAD(3) MemberAccess () ]
// 	|
// 	Expression () [ LOOKAHEAD(3) MemberAccess () ]
// }

// done
// void Type () : {}
// {
// 	(	
// 		<INT> |	<BOOLEAN> | <STRING> | <CHAR> | <VOID> 
// 		| 
// 		<STRUCT> <ID>
// 		// | <ID> // used for typedef C0--
// 	)
// 	(
// 		<STAR>
// 		| 
// 		<LBRACKET> <RBRACKET>
// 	)*
// }
void Type () : {}
{
	(
		<INT> | <BOOLEAN> | <CHAR> | <VOID>
		|
		<STRUCT> Sid()
	)
	( 
		"*" | "[" "]"
	)*
}

void Expression () : {}
{	
	(
		LiteralBasedExpression ()
	)
	[
		LOOKAHEAD(2) LeftRecursionExpression ()
	]
}

void LiteralBasedExpression () : {}
{
	<ALLOC> "(" Type() ")"
	|
	<ALLOC_ARR> "(" Type() "," Expression() ")"
	|
	<NUM>	| <TRUE> | <FALSE> | <NULL>
	|
	"(" Expression() ")"
	|
	LOOKAHEAD(2) Vid() "(" [ Expression() ( "," Expression() )* ] ")"
	|
	Vid()
	|
	<UNOP> Expression()
}

void LeftRecursionExpression () : {}
{
	(
		BinOp() Expression()
		| 
		"?" Expression() ":" Expression()
		| 
		"." Fid()
		| 
		"->" Fid()
		| 
		"[" Expression() "]"
	)
	[ LOOKAHEAD(2) Expression()
	]
}

// [ ] all the others
void  BinOp () : {}
{
	"+" | "-"
}
