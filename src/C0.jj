/**
 * C0-- Parser
 * HS-Fulda - Compiler Constructions
 *
 * @author    Konstantin Ruppel
 * @autor     Juergen Goebel
 * @autor     Sebastian Herr
 * 
 * @date      2017/06/03
 */

PARSER_BEGIN(C0)
public class C0 {
	public static void main(String args[]) {
		C0 parser;
    NodeRoot ast;
		try {
			if (args.length > 0) {
				parser = new C0 (new java.io.FileInputStream(new java.io.File(args[0])));
			} else {
				parser = new C0 (System.in);
			}
			ast = parser.Program();
      System.out.println(ast);
			System.out.println ("[  OK  ]");
		} catch (Exception ex) {
			System.out.println ("[ FAIL ]" + ((args.length > 1) ? ex.getMessage() + "\n\n" : ""));
		}
	}
}
PARSER_END(C0)

SKIP : 
{ 
  " " | "\t" | "\f" | "\n" | "\r" | "\r\n"
  |
  "/*" : IN_ML_COMMENT
  |
  < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >
}

<IN_ML_COMMENT> SKIP :
{
  <~[]>
  |
  "*/" : DEFAULT
}

// Keywords
TOKEN : {
	< INT:        	"int" >
	| < BOOLEAN:    "bool" >
	| < CHAR:       "char" >
	| < VOID:       "void" >
	| < STRUCT:     "struct" >
	| < IF:         "if" >
	| < ELSE:       "else" >
	| < WHILE:      "while" >
	| < FOR:        "for" >
	| < RETURN:     "return" >
	| < TRUE:       "true" >
	| < FALSE:      "false" >
	| < NULL:       "NULL" >
	| < ALLOC:      "alloc" >
  | < ALLOC_ARR:  "alloc_array" >
}

TOKEN : {
  < ID: <LETTER> ( <ALPHANUM> )* >
  |	< #LETTER: ["$","A"-"Z","a"-"z","_"] >
  |	< #ALPHANUM: ["$","A"-"Z","a"-"z","0"-"9","_"] >
  |	< NUM: <DECNUM> | <HEXNUM> >
  |	< DECNUM: "0" | ["1"-"9"](["0"-"9"])* >
  |	< HEXNUM: "0" ("x" | "X") (["0"-"9","a"-"f","A"-"F"])+ >
}

NodeRoot Program () : {NodeRoot root; Node declarationOrStatement;}
{
  {root = new NodeRoot();}
  ( 
    declarationOrStatement=Declaration_Definition()
    {root.addDeclarationOrStatement(declarationOrStatement);}
  )* 
  <EOF> {return root;}
}




Node Sid () : {Token name;}
{
   name=<ID> {return new NodeIdentifier(name);}   // struct name
}

Node Vid () : {Token name;}
{
   name=<ID> {return new NodeIdentifier(name);}   // variable and function name
}

Node Fid () : {Token name;}
{
  name=<ID> {return new NodeIdentifier(name);} // field name
}



Node Declaration_Definition () : {Node result = null; Node newNode; Node type; Node name;
  NodeStructSignature resultStructSig; NodeFunctionSignature resultFunctionSig;}
{
  (
  LOOKAHEAD (3)
	<STRUCT> name=Sid() {resultStructSig = new NodeStructSignature(name);}
    [ "{" {result = new NodeStructDefinition(resultStructSig);}
      ( type=Type() name=Vid() {((NodeStructDefinition)result).addElement(type, name);}";")* "}" 
    ] ";" {if(result == null) {result = new NodeStructDeclaration(resultStructSig);}}
	|
  type=Type() name=Vid() {resultFunctionSig = new NodeFunctionSignature(type, name);}
    "(" [ type=Type() name=Vid()  {resultFunctionSig.addParameter(type, name);}
      ( "," type=Type() name=Vid() {resultFunctionSig.addParameter(type, name);} )* ] ")" 
    ( newNode=Block() {result = new NodeFunctionDefinition(resultFunctionSig, newNode);}  | 
     ";"{result = new NodeFunctionDeclaration(resultFunctionSig);} )
  )
  {return result;}
}

Node Block() : {NodeBlock result; Node newNode; Token token;}
{
  token="{" {result = new NodeBlock(token);} ( newNode=Statement() {result.addStatement(newNode);})* "}"
  {return result;}
}

Node Statement () : {Node result = null; NodeStatementIf resultIf;
  NodeStatementWhile resultWhile; NodeStatementFor resultFor;
  NodeStatementReturn resultReturn; Node newNode = null; Token token;}
{
  (
  newNode=Expression() ";" {result=new NodeStatementExpression(newNode);}
  |
	token=<IF> "(" newNode=Expression() {resultIf=new NodeStatementIf(newNode,token);}")" newNode=Statement() 
    {resultIf.setIf(newNode);}
    [ LOOKAHEAD(2) <ELSE> newNode=Statement() {resultIf.setElse(newNode);}] {result=resultIf;}
	|
	token=<WHILE> "(" newNode=Expression() {resultWhile=new NodeStatementWhile(newNode, token);}")" 
    newNode=Statement()
    {resultWhile.setLoopBody(newNode);result=resultWhile;}
	|
	token=<FOR> {resultFor=new NodeStatementFor(token);} 
    "(" [ newNode=Expression() {resultFor.setInitializer(newNode);}] 
    ";" newNode=Expression() {resultFor.setCondition(newNode);}
     ";" [ newNode=Expression() {resultFor.setIterator(newNode);}] 
    ")" newNode=Statement()
     {resultFor.setLoopBody(newNode);result=resultFor;}
	|
	token=<RETURN> {resultReturn=new NodeStatementReturn(token);}
    [ newNode=Expression() {resultReturn.setReturnValue(newNode);result=resultReturn;} ] ";"
	|
	result=Block() //No need to create a seperate statment block node, everything is already in the block
  )
  {return result;}
}

NodeMemberAccess MemberAccess () : {Node newNode; NodeMemberAccess memberaccess;Token token;}
{
  (
    token="." newNode=Fid() {memberaccess= new NodeMemberAccessDot(newNode, token);}
    |
    token="->" newNode=Fid() {memberaccess= new NodeMemberAccessArrow(newNode, token);}
    |
    token="[" newNode=Expression() "]" {memberaccess= new NodeMemberAccessArray(newNode, token);}
  )
  [
    newNode=MemberAccess() {memberaccess.setAccessingNode(newNode);} 
  ]
  {return memberaccess;}
}

Node Type () : {Node result; Node newNode;Token token;}
{
	(
		token=<INT> {result= new NodeTypeInt(token);} 
    | 
    token=<BOOLEAN> {result= new NodeTypeBool(token);}
    | 
    token=<VOID>{result= new NodeTypeVoid(token);}
		|
		token=<STRUCT> newNode=Sid() {result = new NodeTypeStruct(newNode);}
	)
	( 
		"*" {result = new NodeTypePointer(result);}| "[" "]"{result = new NodeTypeArray(result);}
	)*
  {return result;}
}

NodeFunctionCallArgs FunctionCallArgs () : {NodeFunctionCallArgs result; Node newNode;}
{
  {result = new NodeFunctionCallArgs();}
  [ newNode=Expression() {result.addArg(newNode);}
    ("," newNode=Expression() {result.addArg(newNode);})* 
  ]
  {return result;}
}

Node Expression () : {Node result; Node array_alloc_size; Token token;
  Node type; Node name; Node newNode; NodeExpressionAssign resultAssign;}
{	
  token=<ALLOC> "(" result=Type() ")" {return new NodeExpressionAlloc(result,token);}
  |
  token=<ALLOC_ARR> "(" result=Type() "," array_alloc_size=Expression() ")" 
    {return new NodeExpressionAllocArray(result,token,array_alloc_size);}
  |
  result=OpRang_Assign() {return result;}
  |
  type=Type() name=Vid() {result = new NodeExpressionVariableDefinition(type,name);}
    [ LOOKAHEAD(2) {resultAssign= new NodeExpressionAssign(result);} 
      token="=" newNode=OpRang_Conditional() {resultAssign.setOp("=",token);resultAssign.setSecondary(newNode);result=resultAssign;}]
    {return result;}
}

Node OpRang_Assign () : {Node result; NodeExpressionBinary operator = null; NodeExpressionAssign resultAssign; Token opToken;}
{
  result=OpRang_Conditional()
  [ 
    LOOKAHEAD(2)
    {resultAssign= new NodeExpressionAssign(result);}
    (
      opToken="="  | 
      opToken="+=" {operator = new NodeExpressionSum(result);      operator.setOp("+", opToken);}|    //Untangle "a += b;" to "a = a + b"
      opToken="-=" {operator = new NodeExpressionSum(result);      operator.setOp("-", opToken);}| 
      opToken="*=" {operator = new NodeExpressionFactor(result);   operator.setOp("*", opToken);}| 
      opToken="/=" {operator = new NodeExpressionFactor(result);   operator.setOp("/", opToken);}| 
      opToken="%=" {operator = new NodeExpressionFactor(result);   operator.setOp("%", opToken);}| 
      opToken="<<="{operator = new NodeExpressionBitShift(result); operator.setOp("<<", opToken);}| 
      opToken=">>="{operator = new NodeExpressionBitShift(result); operator.setOp(">>", opToken);}| 
      opToken="&=" {operator = new NodeExpressionBitAnd(result);   operator.setOp("&", opToken);}| 
      opToken="^=" {operator = new NodeExpressionBitXor(result);   operator.setOp("^", opToken);}| 
      opToken="|=" {operator = new NodeExpressionBitOr(result);    operator.setOp("|", opToken);}
    ) 
    result=OpRang_Conditional(){resultAssign.setOp("=", opToken);
                                if(operator == null){resultAssign.setSecondary(result);} 
                                else{operator.setSecondary(result); resultAssign.setSecondary(operator);}
                                result=resultAssign;}
  ]
  {return result;}
}

Node OpRang_Conditional () : {Node result; NodeStatementIf resultIf; Token token;}
{
  //Using the normal If Node since this here is just a shorthand for the normal if then else construct
  result=OpRang_LogicalOr() 
  [ LOOKAHEAD(2)  
    ( token="?" {resultIf=new NodeStatementIf(result, token);} result=Expression() {resultIf.setIf(result);}
      ":" result=Expression() {resultIf.setElse(result); result = resultIf;}) 
  ]
  {return result;}
}

Node OpRang_LogicalOr () : {Node result; NodeExpressionBinary resultBin;Token opToken;}
{
  result=OpRang_LogicalAnd() [ {resultBin = new NodeExpressionLogicalOr(result);} 
        ( opToken="||" ) result=OpRang_LogicalOr()  {resultBin.setOp("||",opToken); resultBin.setSecondary(result);result=resultBin;}]
  {return result;}
}

Node OpRang_LogicalAnd () : {Node result;NodeExpressionBinary resultBin;Token opToken;}
{
  result=OpRang_BitOr() [ {resultBin = new NodeExpressionLogicalAnd(result);} 
        ( opToken="&&" ) result=OpRang_LogicalAnd()  {resultBin.setOp("&&",opToken);resultBin.setSecondary(result);result=resultBin;}]
  {return result;}
}

Node OpRang_BitOr () : {Node result;NodeExpressionBinary resultBin;Token opToken;}
{
  result=OpRang_BitXor() [ {resultBin = new NodeExpressionBitOr(result);} 
        ( opToken="|" ) result=OpRang_BitOr()  {resultBin.setOp("|",opToken);resultBin.setSecondary(result);result=resultBin;}]
  {return result;}
}

Node OpRang_BitXor () : {Node result;NodeExpressionBinary resultBin;Token opToken;}
{
  result=OpRang_BitAnd() [ {resultBin = new NodeExpressionBitXor(result);} 
        ( opToken="^" ) result=OpRang_BitXor()  {resultBin.setOp("^",opToken);resultBin.setSecondary(result);result=resultBin;}]
  {return result;}
}

Node OpRang_BitAnd () : {Node result;NodeExpressionBinary resultBin;Token opToken;}
{
  result=OpRang_Equality() [ {resultBin = new NodeExpressionBitAnd(result);} 
        ( opToken="&" ) result=OpRang_BitAnd() {resultBin.setOp("&",opToken);resultBin.setSecondary(result);result=resultBin;} ]
  {return result;}
}

Node OpRang_Equality () : {Node result;NodeExpressionBinary resultBin;Token opToken;}
{
  result=OpRang_Compare() [ {resultBin = new NodeExpressionEquality(result);} 
        ( opToken="==" {resultBin.setOp("==",opToken);}| 
          opToken="!=" {resultBin.setOp("!=",opToken);}) 
        result=OpRang_Equality() {resultBin.setSecondary(result);result=resultBin;}]
 {return result;}
}

Node OpRang_Compare () : {Node result;NodeExpressionBinary resultBin;Token opToken;}
{
  result=OpRang_BitShift() [ {resultBin = new NodeExpressionCompare(result);} 
        ( opToken="<" {resultBin.setOp("<",opToken);}| 
          opToken=">" {resultBin.setOp(">",opToken);}| 
          opToken=">=" {resultBin.setOp(">=",opToken);}| 
          opToken="<=" {resultBin.setOp("<=",opToken);}) 
        result=OpRang_Compare() {resultBin.setSecondary(result);result=resultBin;}]
  {return result;}
}

Node OpRang_BitShift () : {Node result;NodeExpressionBinary resultBin;Token opToken;}
{
  result=OpRang_Sum() [ {resultBin = new NodeExpressionBitShift(result);} 
        ( opToken="<<" {resultBin.setOp("<<",opToken);}| 
          opToken=">>" {resultBin.setOp(">>",opToken);}) 
        result=OpRang_BitShift() {resultBin.setSecondary(result);result=resultBin;}]
  {return result;}
}

Node OpRang_Sum () : {Node result;NodeExpressionBinary resultBin;Token opToken;}
{
  result=OpRang_Factor() [ {resultBin = new NodeExpressionSum(result);} 
        ( opToken="+" {resultBin.setOp("+",opToken);}| 
          opToken="-" {resultBin.setOp("-",opToken);}) 
        result=OpRang_Sum() {resultBin.setSecondary(result);result=resultBin;}]
  {return result;}
}

Node OpRang_Factor () : {Node result; Node newNode;NodeExpressionBinary resultBin;Token opToken;}
{
  result=OpRang_Unary() [ {resultBin = new NodeExpressionFactor(result);} 
        (opToken="*" {resultBin.setOp("*",opToken);} |
         opToken="/" {resultBin.setOp("/",opToken);} | 
         opToken="%" {resultBin.setOp("%",opToken);} ) 
         newNode=OpRang_Factor() {resultBin.setSecondary(newNode);result=resultBin;}] 
  {return result;}
}

Node OpRang_Unary () : {NodeExpressionUnary unaryOp = null; Node result; 
  NodeMemberAccess memberaccess = null; NodeFunctionCallArgs functionArgs; Token token;}
{
  //gather information for this node...
  [
    token="*" {unaryOp=new NodeExpressionUnaryDereference(token);} | 
    token="-" {unaryOp=new NodeExpressionUnaryMinus(token);} | 
    token="~" {unaryOp=new NodeExpressionUnaryBitwiseNegation(token);} |
    token="!" {unaryOp=new NodeExpressionUnaryNegation(token);}
  ]
  (
    result=Vid() [ "(" functionArgs=FunctionCallArgs() ")" 
                    {result = new NodeExpressionFunctionCall(result, functionArgs);} 
                 | 
                   token="--" { result = new NodeExpressionDecrement(result, token);}
                 | 
                   token="++" { result = new NodeExpressionIncrement(result, token);}
                 ]
    |
      token=<NUM>  {result= new NodeExpressionConstNum(token);}	
    | 
      token=<TRUE> {result= new NodeExpressionConstTrue(token);} 
    | 
      token=<FALSE>{result= new NodeExpressionConstFalse(token);} 
    | 
      token=<NULL> {result= new NodeExpressionConstNull(token);}
    |
    token="(" result=OpRang_Conditional() {result = new NodeExpressionBrackets(result, token);} ")"
  )
  [
    /*
     * If there is a constant or function before that, then the type checker will complain here,
     * unless the returned item is a stack or something :)
     */
    memberaccess=MemberAccess()
  ]
  //...and assemble it
  {
    if(memberaccess != null)
    { memberaccess.setAccessingNode(result); result=memberaccess; }
    if(unaryOp != null)
    { unaryOp.setInternNode(result); result=unaryOp; }
    return result;
  }
}