/**
 * C0-- Parser
 * HS-Fulda - Compiler Constructions
 *
 * @author    Konstantin Ruppel
 * @autor     Juergen Goebel
 * @autor     Sebastian Herr
 * 
 * @date      2017/06/03
 */

PARSER_BEGIN(C0)
public class C0 {
	static boolean x = true;
	public static void main(String args[]) {
		C0 parser;
		try {
			if (args.length > 0) {
				parser = new C0 (new java.io.FileInputStream(new java.io.File(args[0])));
			} else {
				parser = new C0 (System.in);
			}
			parser.Program();
			System.out.println ("[  OK  ]");
		} catch (Exception ex) {
			System.out.println ("[ FAIL ]" + ((args.length > 1) ? ex.getMessage() + "\n\n" : ""));
		}
	}
}
PARSER_END(C0)

SKIP : 
{ 
  " " | "\t" | "\f" | "\n" | "\r" | "\r\n"
  |
  "/*" : IN_ML_COMMENT
  |
  < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >
}

<IN_ML_COMMENT> SKIP :
{
  <~[]>
  |
  "*/" : DEFAULT
}

// Keywords
TOKEN : {
	< INT:        	"int" >
	| < BOOLEAN:    "bool" >
	| < CHAR:       "char" >
	| < VOID:       "void" >
	| < STRUCT:     "struct" >
	| < IF:         "if" >
	| < ELSE:       "else" >
	| < WHILE:      "while" >
	| < FOR:        "for" >
	| < RETURN:     "return" >
	| < TRUE:       "true" >
	| < FALSE:      "false" >
	| < NULL:       "NULL" >
	| < ALLOC:      "alloc" >
  | < ALLOC_ARR:  "alloc_array" >
}

TOKEN : {
	< ID: <LETTER> ( <ALPHANUM> )* >
	|	< #LETTER: ["$","A"-"Z","a"-"z","_"] >
	|	< #ALPHANUM: ["$","A"-"Z","a"-"z","0"-"9","_"] >
	|	< NUM: <DECNUM> | <HEXNUM> >
	|	< DECNUM: "0" | ["1"-"9"](["1"-"9"])* >
	|	< HEXNUM: "0" ("x" | "X") (["0"-"9","a"-"f","A"-"F"])+ >
}

void Program () : {}
{
	( 
    Declaration_Definition()
  )* 
  <EOF>
}

void Sid () : {}
{
  <ID>  // struct name
}

void Vid () : {}
{
  <ID>  // variable and function name
}

void Fid () : {}
{
  <ID>  // field name
}

void Declaration_Definition () : {}
{
  LOOKAHEAD (3)
	<STRUCT> Sid() [ "{" ( Type() Vid() ";" )* "}" ] ";"
	|
  Type() Vid() "(" [ Type() Vid() ( "," Type() Vid() )* ] ")" ( "{" ( Statement() )* "}" | ";" )
}

void Statement () : {}
{
  Expression() ";"
  |
	<IF> "(" Expression() ")" Statement() [ LOOKAHEAD(2) <ELSE> Statement() ]
	|
	<WHILE> "(" Expression() ")" Statement()
	|
	<FOR> "(" [ Expression() ] ";" Expression() ";" [ Expression() ] ")" Statement()
	|
	<RETURN> [ Expression() ] ";"
	|
	"{" ( Statement() )* "}"
}

void MemberAccess () : {}
{
  (
    "." Fid()
    |
    "->" Fid()
    |
    "[" Expression() "]"
  )
  [
    MemberAccess()
  ]
}

void Type () : {}
{
	(
		<INT> | <BOOLEAN> | <CHAR> | <VOID>
		|
		<STRUCT> Sid()
	)
	( 
		"*" | "[" "]"
	)*
}

void FunctionCallArgs () : {}
{
  [ Expression() ("," Expression() )* ]
}

void Expression () : {}
{	
  <ALLOC> "(" Type() ")"
  |
  <ALLOC_ARR> "(" Type() "," Expression() ")"
  |
  OpRang_Assign()
  |
  Type() Vid() [ LOOKAHEAD(2) "=" OpRang_Conditional() ]
}

void OpRang_Assign () : {}
{
  OpRang_Conditional()
  [ 
    LOOKAHEAD(2)
    (
      "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | "&=" | "^=" | "|=" 
    ) 
    OpRang_Conditional()
  ]
}

void OpRang_Conditional () : {}
{
  OpRang_LogicalOr() [ LOOKAHEAD(2) ( "?" Expression() ":" Expression() ) ]
}

void OpRang_LogicalOr () : {}
{
  OpRang_LogicalAnd() [ ( "||" ) OpRang_LogicalOr() ]
}

void OpRang_LogicalAnd () : {}
{
  OpRang_BitOr() [ ( "&&" ) OpRang_LogicalAnd() ]
}

void OpRang_BitOr () : {}
{
  OpRang_BitXor() [ ( "|" ) OpRang_BitOr() ]
}

void OpRang_BitXor () : {}
{
  OpRang_BitAnd() [ ( "^" ) OpRang_BitXor() ]
}

void OpRang_BitAnd () : {}
{
  OpRang_Equality() [ ( "&" ) OpRang_BitAnd() ]
}

void OpRang_Equality () : {}
{
  OpRang_Compare() [ ( "==" | "!=" ) OpRang_Equality() ]
}

void OpRang_Compare () : {}
{
  OpRang_BitShift() [ ( "<" | ">" | ">=" | "<=" ) OpRang_Compare() ]
}

void OpRang_BitShift () : {}
{
  OpRang_Sum() [ ("<<" | ">>" ) OpRang_BitShift() ]
}

void OpRang_Sum () : {}
{
  OpRang_Factor() [ ("+" | "-" ) OpRang_Sum() ]
}

void OpRang_Factor () : {}
{
  OpRang_Unary() [ ("*" | "/" | "%" ) OpRang_Factor() ]
}

void OpRang_Unary () : {}
{
  [
    "*" | "-" | "~" | "!"
  ]
  (
    Vid() [ "(" FunctionCallArgs() ")" | "--" | "++" ]
    |
    <NUM>	| <TRUE> | <FALSE> | <NULL>
    |
    "(" OpRang_Conditional() ")"
  )
  [
    MemberAccess()
  ]
}