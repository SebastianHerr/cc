options
{
  DEBUG_PARSER = true;
  DEBUG_TOKEN_MANAGER = true;
}

PARSER_BEGIN(C0)
public class C0 {
	static boolean x = true;
	public static void main(String args[]) {
		C0 parser;
		try {
			if (args.length > 0) {
				parser = new C0 (new java.io.FileInputStream(new java.io.File(args[0])));
			} else {
				parser = new C0 (System.in);
			}
			parser.Program();
			System.out.println ("[  OK  ]");
		} catch (Exception ex) {
			System.out.println ("[ FAIL ]\n\n" + ex.getMessage());
		}
	}
}
PARSER_END(C0)

SKIP : { " " | "\t" | "\n" | "\r" | "\r\n" | "/*" : IN_COMMENT }
<IN_COMMENT> MORE : {	<~[]> | "*/" : DEFAULT }

// Keywords
TOKEN : {
	< INT:        	"int" >
	| < BOOLEAN:    "bool" >
	| < STRING:     "string" >
	| < CHAR:       "char" >
	| < VOID:       "void" >
	| < STRUCT:     "struct" >
	| < IF:         "if" >
	| < ELSE:       "else" >
	| < WHILE:      "while" >
	| < FOR:        "for" >
	| < RETURN:     "return" >
	| < TRUE:       "true" >
	| < FALSE:      "false" >
	| < NULL:       "NULL" >
	| < ALLOC:      "alloc" >
  | < ALLOC_ARR:  "alloc_array" >
}

// Separators
TOKEN : {
	< LPAREN: "(" >
	| < RPAREN: ")" >
	| < LBRACE: "{" >
	| < RBRACE: "}" >
	| < LBRACKET: "[" >
  | < RBRACKET: "]" >
  | < LWICKET: "<" >
  | < RWICKET: ">" >
  | < COLON: ":" >
  | < SEMICOLON: ";" >
	| < COMMA: "," >
	| < DOT: "." >
	| < EOL: "\n" | "\r" | "\r\n" | "\f" >
}

// Operators
TOKEN : {
	< STAR: "*" >
  | < PLUSPLUS: "++">
  | < MINUSMINUS: "--">
  | < EQUALS: "=">
  | < ASSIGN: "->">
  | < QUESTION: "?">
  | < ASNOP: "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | "&=" | "^=" | "|=" >  
  | < UNOP: "!" | "~" | "-" | "*" >
}

// Lexical Tokens
TOKEN : {
	< ID: <LETTER> ( <ALPHANUM> )* >
	|	< #LETTER: ["$","A"-"Z","a"-"z","_"] >
	|	< #ALPHANUM: ["$","A"-"Z","a"-"z","0"-"9","_"] >
	|	< NUM: <DECNUM> | <HEXNUM> >
	|	< DECNUM: "0" | ["1"-"9"](["1"-"9"])* >
	|	< HEXNUM: "0" ("x" | "X") (["0"-"9","a"-"f","A"-"F"])+ >
	// | < STRLIT: "\"" (<SCHAR>)* "\"" >
	// |   < CHRLIT: "'" <CCHAR> "'" >
	// |   < LIBLIT: "<" (<LCHAR>)* ">" >
  // |   < SCHAR: <NCHAR> | <ESC> >
	// |   < CCHAR: <NCHAR> | <ESC> | "\"" | "\0" >
	// |   < NCHAR: (~["\""])+ >
	// |   < LCHAR: (~[">"])+ >
	// |   < ESC: "\n" | "\t" | "\\v" | "\b" | "\r" | "\f" | "\\a" | "\\" | "\'" | "\"" >
	// |   < SEP: "(" | ")" | "[" | "]" | "{" | "}" | "," | ";" >
	 // |	< BINOP: "." | "->" | "*" | "/" | "%" | "+" | "-" | "<<" | ">>" | "<" | "<=" | ">=" | ">" | "==" | "!=" | "&" | "^" | "|" | "&&" | "||" | "?" | ":" >
	// |	< POSTOP: "--" | "++" >
}

void Program() : {}
{
	Type ()
	// ( Import () )*
	// ( LOOKAHEAD(Declaration()) Declaration () )*
	// ( LOOKAHEAD(Definition()) Definition () )*
}

void Sid() : {}
{
  <ID>  // struct name
}

void Vid() : {}
{
  <ID>  // variable and function name
}

void Fid() : {}
{
  <ID>  // field name
}

void Declaration_Definition() : {}
{
  LOOKAHEAD (3) // otherwise posssible conflict with a definition of a function with return type struct
	<STRUCT> Sid() [ <LBRACE> ( Type() Vid() <SEMICOLON> )* <RBRACE> ] <SEMICOLON>
	|
  Type() Vid() <LPAREN> [ Type() Vid() ( <COMMA> Type() Vid() )* ] <RPAREN> ( <LBRACE> ( Statement() )* <RBRACE> | <SEMICOLON> )
}

// [ ] reduce LOOKAHEAD for Simple()
void Statement () : {}
{
	LOOKAHEAD(Simple () <SEMICOLON>) Simple () <SEMICOLON>
	|
	<IF> <LPAREN> Expression () <RPAREN> Statement () [ LOOKAHEAD(2) <ELSE> Statement () ]
	|
	<WHILE> <LPAREN> Expression () <RPAREN> Statement ()
	|
	<FOR> <LPAREN> [ Simple () ] <SEMICOLON> Expression () <SEMICOLON> [ Simple () ] <RPAREN> Statement ()
	|
	<RETURN> [ Expression () ] <SEMICOLON>
	|
	<ASSERT> <LPAREN> Expression () <RPAREN> <SEMICOLON>
	|
	<ERROR> <LPAREN> Expression () <RPAREN> <SEMICOLON>
	|
	<LBRACE> ( Statement () )* <RBRACE>
}

void Simple () : {}
{
	LOOKAHEAD(Expression()) Expression ()
  |
	LOOKAHEAD(3) MemberAccess () <ASNOP> Expression ()
	|
	LOOKAHEAD(3) MemberAccess () <POSTOP>
	|
	Type () <ID> [ <EQUALS> Expression () ]
}

// done
void MemberAccess () : {}
{
	(
		<ID>
		|	
		<STAR> MemberAccess ()
		|	
		<LPAREN> MemberAccess () <RPAREN>
	)
	[ LOOKAHEAD(2) LeftRecursionMemberAccess () ]
}

void LeftRecursionMemberAccess () : {}
{
	<DOT> <ID> [ LOOKAHEAD(3) MemberAccess () ]
	|	
	<POINTERACCESS> <ID> [ LOOKAHEAD(3) MemberAccess () ]
	|
	Expression () [ LOOKAHEAD(3) MemberAccess () ]
}

// done
// void Type () : {}
// {
// 	(	
// 		<INT> |	<BOOLEAN> | <STRING> | <CHAR> | <VOID> 
// 		| 
// 		<STRUCT> <ID>
// 		// | <ID> // used for typedef C0--
// 	)
// 	(
// 		<STAR>
// 		| 
// 		<LBRACKET> <RBRACKET>
// 	)*
// }
void Type() : {}
{
	<INT> [ TypeDash() ]
	|
	<BOOLEAN> [ TypeDash() ]
	|
	<STRING> [ TypeDash() ]
	|
	<CHAR> [ TypeDash() ]
	|
	<VOID> [ TypeDash() ]
	|
	<STRUCT> <ID> [ TypeDash() ]
}

void TypeDash() : {}
{
	<STAR> [ TypeDash() ]
	|
	<LBRACKET> <RBRACKET> [ TypeDash() ]
}

void Expression () : {}
{	
	(
		LiteralBasedExpression ()
	)
	(
		LOOKAHEAD(2) LeftRecursionExpression ()
	)*
}

void LiteralBasedExpression () : {}
{
	<NUM>	| <TRUE> | <FALSE> | <NULL>
	|
	LOOKAHEAD(2) <ID>
	|
	<ID> <LPAREN> [ Expression () ( <COMMA> Expression () )* ] <RPAREN>
	|
	<LPAREN> Expression () <RPAREN>
	|
	<LBRACE> Expression () <RBRACE>
	|
	<UNOP> Expression ()
	|
	<ALLOC> <LPAREN> Type () <RPAREN>
	|
	<ALLOC_ARR> <LPAREN> Type () <COMMA> Expression () <RPAREN>
}

void LeftRecursionExpression () : {}
{
	(
		LiteralBasedExpression ()
	)
	|
	(
		<QUESTION> Expression () <COLON> Expression ()
		| 
		<BINOP> Expression ()
		| 
		<POSTOP>
		| 
		<DOT> <ID>
		| 
		<POINTERACCESS> <ID>
		| 
		<LBRACKET> Expression () <RBRACKET>
	)
}
